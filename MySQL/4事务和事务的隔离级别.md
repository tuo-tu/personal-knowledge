## 1.4.事务和事务的隔离级别

### 1.4.1.为什么需要事务

事务是数据库管理系统（DBMS）执行过程中的一个逻辑单位（不可再进行分割），由一个有限的数据库操作序列构成（多个DML语句，select语句不包含事务），要不全部成功，要不全部不成功。

A 给B 要划钱，A 的账户-1000元， B 的账户就要+1000元，这两个update 语句必须作为一个整体来执行，不然A 扣钱了，B 没有加钱这种情况就是错误的。那么事务就可以保证A 、B 账户的变动要么全部一起发生，要么全部一起不发生。

### 1.4.2.事务特性

事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。

**l  原子性（atomicity）**

**l  一致性（consistency）**

**l  隔离性（isolation）**

**l  持久性（durability）**

#### 1.4.2.1.原子性（atomicity）

一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，要么全部失败，对于一个事务来说，不能只执行其中的一部分操作。比如：

连老师借给李老师1000元：

1.连老师工资卡扣除1000元

2.李老师工资卡增加1000元

整个事务的操作要么全部成功，要么全部失败，不能出现连老师工资卡扣除，但是李老师工资卡不增加的情况。如果原子性不能保证，就会很自然的出现一致性问题。

#### 1.4.2.2.一致性（consistency）

一致性是指事务将数据库从一种一致性转换到另外一种一致性状态，在事务开始之前和事务结束之后数据库中数据的完整性没有被破坏。

连老师借给李老师1000元：

1.连老师工资卡扣除1000元

2.李老师工资卡增加1000元

扣除的钱（-500） 与增加的钱（500） 相加应该为0，或者说连老师和李老师的账户的钱加起来，前后应该不变。

#### 1.4.2.3.持久性（durability）

一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失。

#### 1.4.2.4.隔离性（isolation）

**一个事务的执行不能被其他事务干扰**。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

如果隔离性不能保证，会导致什么问题？

连老师借给李老师生活费，借了两次，每次都是1000，连老师的卡里开始有10000，李老师的卡里开始有500，从理论上，借完后，连老师的卡里有8000，李老师的卡里应该有2500。

我们将连老师向李老师同时进行的两次转账操作分别称为T1和T2，在现实世界中T1和T2是应该没有关系的，可以先执行完T1，再执行T2，或者先执行完T2，再执行T1，结果都是一样的。但是很不幸，真实的数据库中T1和T2的操作可能交替执行的，执行顺序就有可能是：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/db81c54724b54e749ec5dd801f29e91b.png)

如果按照上图中的执行顺序来进行两次转账的话，最终我们看到，连老师的账户里还剩9000元钱，相当于只扣了1000元钱，但是李老师的账户里却成了2500元钱，多了10000元，这银行岂不是要亏死了？

所以对于现实世界中状态转换对应的某些数据库操作来说，不仅要保证这些操作以原子性的方式执行完成，而且要保证其它的状态转换不会影响到本次状态转换，这个规则被称之为隔离性。

### 1.4.3.事务并发引发的问题

我们知道MySQL是一个客户端／服务器架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（Session）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。

在上面我们说过事务有一个称之为隔离性的特性，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据，这样的话并发事务的执行就变成了串行化执行。

但是对串行化执行性能影响太大，我们既想保持事务的一定的隔离性，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，当我们舍弃隔离性的时候，可能会带来什么样的数据问题呢？

#### 1.4.3.1.脏读

当**一个事务读取到了另外一个事务修改了但未提交的数据**，被称为脏读。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/05e67865973a410e93190c52a74be697.png)

1、在事务A执⾏过程中，事务A对数据资源进⾏了修改，事务B读取了**事务A修改后的数据。**
2、由于某些原因，事务A并没有完成提交，发⽣了RollBack操作，则事务B读取的数据就是脏数据。这种读取到另⼀个事务未提交的数据的现象就是脏读(Dirty Read)。

#### 1.4.3.2.不可重复读

当事务内相同的记录被检索两次，且两次得到的结果不同时，此现象称为不可重复读。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/3895ad68683747e88b114bba40f48ad9.png)

事务B读取了两次数据资源，**在这两次读取的过程中事务A修改了数据**，导致事务B在这两次读取出来的数据不⼀致。

#### 1.4.3.3.幻读

在事务执行过程中，另一个事务将新记录添加到正在读取的事务中时，会发生幻读。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/3a92feb9aa014a7eaaf784d1c7057822.png)

事务B前后两次读取**同⼀个范围**的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后⼀次读取到前⼀次查询没有看到的⾏。
幻读和不可重复读有些类似，但是幻读重点强调了读取到了之前读取没有获取到的记录。

### 1.1.4.SQL标准中的四种隔离级别

我们上边介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题也有轻重缓急之分，我们给这些问题按照严重性来排一下序：

脏读 > 不可重复读 > 幻读

我们上边所说的舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，越严重的问题就越可能发生。有一帮人（并不是设计MySQL的大叔们）制定了一个所谓的SQL标准，在标准中设立了4个隔离级别：

**READ UNCOMMITTED：未提交读。**

**READ COMMITTED：已提交读。**

**REPEATABLE READ：可重复读。**

**SERIALIZABLE：可串行化。**

SQL标准中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：

也就是说：

**READ UNCOMMITTED隔离级别下，可能发生脏读、不可重复读和幻读问题。**

**READ COMMITTED隔离级别下，可能发生不可重复读和幻读问题，但是不可以发生脏读问题。**

**REPEATABLE READ隔离级别下，可能发生幻读问题，但是不可以发生脏读和不可重复读的问题。**

**SERIALIZABLE隔离级别下，各种问题都不可以发生。**

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/21048532674b4486a21b90258b046a15.png" alt="image.png" style="zoom: 50%;" />

### 1.4.5.MySQL中的隔离级别

不同的数据库厂商对SQL标准中规定的四种隔离级别支持不一样，比方说Oracle就只支持READ COMMITTED和SERIALIZABLE隔离级别。本书中所讨论的MySQL虽然支持4种隔离级别，但与SQL标准中所规定的各级隔离级别允许发生的问题却有些出入，**MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的。**

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/1452d922eb0f4dda803126784436e8b2.png" alt="image.png" style="zoom:50%;" />

**MySQL的默认隔离级别为REPEATABLE READ**，我们可以手动修改事务的隔离级别。

#### 1.4.5.1.如何设置事务的隔离级别

我们可以通过下边的语句修改事务的隔离级别：

SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;

其中的level可选值有4个：

```sql
level: {
    REPEATABLE READ
   | READ COMMITTED
   | READ UNCOMMITTED
   | SERIALIZABLE
}
```

设置事务的隔离级别的语句中，在SET关键字后可以放置GLOBAL关键字、SESSION关键字或者什么都不放，这样会对不同范围的事务产生不同的影响，具体如下：

**使用GLOBAL关键字（在全局范围影响）：**

比方说这样：

```sql
SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

则： **只对执行完该语句之后产生的会话起作用**。当前已经存在的会话无效。

**使用SESSION关键字（在会话范围影响）：**

比方说这样：

```sql
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

则：**对当前会话的所有后续的事务有效**

该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务。

如果在事务之间执行，则对后续的事务有效。

**上述两个关键字都不用（只对执行语句后的下一个事务产生影响）：**

比方说这样：

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

则：**只对当前会话中下一个即将开启的事务有效。下一个事务执行完后，后续事务将恢复到之前的隔离级别。**该语句不能在已经开启的事务中间执行，会报错的。

如果我们在服务器启动时想改变事务的默认隔离级别，可以修改启动参数`transaction-isolation`的值，比方说我们在启动服务器时指定了--transaction-isolation=SERIALIZABLE，那么事务的默认隔离级别就从原来的REPEATABLE READ变成了SERIALIZABLE。

想要**查看当前会话默认的隔离级别**可以通过查看系统变量transaction_isolation的值来确定：

```sql
SHOW VARIABLES LIKE 'transaction_isolation';
```

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/a863d53bff964d74a21b52de56bc97df.png" alt="image.png" style="zoom:80%;" />

或者使用更简便的写法：

```sql
SELECT @@transaction_isolation;
```

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/390b1f7f9b7947ee97716cdc08d3848a.png)

注意：transaction_isolation是在MySQL 5.7.20的版本中引入来替换tx_isolation的，如果你使用的是之前版本的MySQL，请将上述用到系统变量transaction_isolation的地方替换为tx_isolation。

### 1.4.6.MySQL事务

#### 1.4.6.1.事务基本语法

**事务开始**

1、begin

2、**START TRANSACTION（推荐）**

3、begin work

**事务回滚**

rollback

**事务提交**

commit

使用事务插入两行数据，commit后数据还在

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/874c5a5d37c44347827edc01c7646d58.png" alt="image.png" style="zoom:80%;" />

使用事务插入两行数据，rollback后数据没有了

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/80e27d57435b4034a20c3ea4566c7674.png" alt="image.png" style="zoom:80%;" />

#### 1.4.6.2.保存点

如果你开启了一个事务，执行了很多语句，忽然发现某条语句有点问题，你只好使用ROLLBACK语句来让数据库状态恢复到事务执行之前的样子，然后一切从头再来，**但是可能根据业务和数据的变化，不需要全部回滚**。所以MySQL里提出了一个保存点（英文：savepoint）的概念，**就是在事务对应的数据库语句中打几个点，我们在调用ROLLBACK语句时可以指定会滚到哪个点，而不是回到最初的原点。**定义保存点的语法如下：

SAVEPOINT 保存点名称；

当我们想回滚到某个保存点时，可以使用下边这个语句（下边语句中的单词WORK和SAVEPOINT是可有可无的）：

```sql
ROLLBACK TO [SAVEPOINT] 保存点名称;
```

不过如果ROLLBACK语句后边不跟随保存点名称的话，会直接回滚到事务执行之前的状态。

如果我们想删除某个保存点，可以使用这个语句：

```sql
RELEASE SAVEPOINT 保存点名称;
```

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/3dd600ff2c384d5f8e348c8bc33a6c76.png" alt="image.png" style="zoom:80%;" />

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/2e56bef3f9954c3f943168d546ae662f.png" alt="image.png" style="zoom:80%;" />

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/dbca0f38164045eda2543112de99d69b.png" alt="image.png"  />

#### 1.4.6.3.隐式提交

当我们使用START TRANSACTION或者BEGIN语句开启了一个事务，或者把系统变量autocommit的值设置为OFF时，事务就不会进行自动提交，但是如果我们输入了某些语句之后就会悄悄的提交掉，就像我们输入了COMMIT语句了一样，这种因为某些特殊的语句而导致事务提交的情况称为隐式提交，这些会导致事务隐式提交的语句包括：

##### 1.4.6.3.1.执行DDL

定义或修改数据库对象的数据定义语言（Datadefinition language，缩写为：DDL）。

所谓的数据库对象，指的就是数据库、表、视图、存储过程等等这些东西。当我们使用CREATE、ALTER、DROP等语句去修改这些所谓的数据库对象时，就会**隐式的提交前边语句所属于的事务**，就像这样：

```sql
BEGIN;

SELECT ... # 事务中的一条语句

UPDATE ... # 事务中的一条语句

... # 事务中的其它语句

CREATE TABLE ...
```

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/34acaa6366574b638f74d96d65f76274.png" alt="image.png" style="zoom:80%;" />

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/9a70501b6a0645f389deae88494426fa.png" alt="image.png" style="zoom:80%;" />

**此语句会隐式的提交前边语句所属于的事务**

##### 1.4.6.3.2.隐式使用或修改mysql数据库中的表

当我们使用`ALTER USER、CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SET PASSWORD`等语句时也会隐式的提交前边语句所属于的事务。

##### 1.4.6.3.3.事务控制或关于锁定的语句

当我们在一个会话里，**一个事务还没提交或者回滚时就又使用START TRANSACTION或者BEGIN语句**开启了另一个事务时，会隐式的提交上一个事务，比如这样：

```sql
BEGIN;

SELECT ... # 事务中的一条语句

UPDATE ... # 事务中的一条语句

... # 事务中的其它语句

BEGIN; # 此语句会隐式的提交前边语句所属于的事务
```

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/6aaf9a1f630c4210996782d1c6fa6a97.png" alt="image.png" style="zoom:80%;" />

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/93a9ef0063704f31b47838b257fb6cf0.png)

或者**当前的autocommit系统变量的值为OFF，我们手动把它调为ON时**，也会隐式的提交前边语句所属的事务。

或者使用`LOCK TABLES、UNLOCK TABLES`等关于锁定的语句也会隐式的提交前边语句所属的事务。

##### 1.4.6.3.4.加载数据的语句

比如我们使用**LOAD DATA**语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。

##### 1.4.6.3.5.关于MySQL复制的一些语句

使用`START SLAVE、STOP SLAVE、RESET SLAVE、CHANGE MASTER TO`等语句时也会隐式的提交前边语句所属的事务。

##### 1.4.6.3.6.其它的一些语句

使用ANALYZE TABLE、CACHE INDEX、CHECK TABLE、FLUSH、 LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET等语句也会隐式的提交前边语句所属的事务。

## 1.5.MVCC

**MVCC（多版本并发控制，Multi-Version Concurrency Control）**，MVCC 通过为每条记录保留多个版本，在**不加锁的情况下**实现一致性读（快照读）和高并发。（主要包括**版本链**和**ReadView**）
同一行数据平时发生读写请求时，会上锁阻塞住。但MVCC用更好的方式去处理读--写请求，**做到在发生读--写请求冲突时不用加锁。**
**这个读是指的快照读，而不是当前读**，当前读是一种加锁操作，是悲观锁。

chatgpt：

- “悲观锁” 是数据库中 **并发控制的一种策略**，主要特点是：**认为并发操作一定会发生冲突，所以在读取或修改数据时，主动加锁来防止其他事务修改数据。**

- “乐观锁”是数据库中 **并发控制的一种方式**，与悲观锁相反，它**假设不会发生并发冲突**，在数据更新时再去**校验是否有冲突**，如果有，则**回滚或重试**。

  乐观锁是一种无锁并发控制机制，它通过版本号或时间戳来检测数据冲突，而不是真正加锁。

**乐观锁举例1（版本号）**：商品库存扣减场景

```sql
-- 假设初始数据: id=1, stock=10, version=0

-- 事务1
START TRANSACTION;
SELECT stock, version FROM products WHERE id = 1; -- 得到 stock=10, version=0

-- 此时事务2也查询了相同数据并先完成了更新
-- 事务2已执行: 
-- UPDATE products SET stock=9, version=1 WHERE id=1 AND version=0;

-- 事务1继续执行更新
UPDATE products 
SET stock = stock - 1, 
    version = version + 1 
WHERE id = 1 AND version = 0;

-- 检查影响行数
SELECT ROW_COUNT(); -- 返回0表示更新失败

-- 此时应该回滚并重试或提示用户
ROLLBACK;

```

**乐观锁举例2（时间戳）**

```sql
-- 第一步：查询商品信息和当前时间戳
SELECT id, name, stock, update_time 
FROM products 
WHERE id = 1;

-- 假设返回结果：
-- id:1, name:"iPhone 15", stock:100, update_time:"2023-11-01 10:00:00"

-- 第二步：更新时检查时间戳是否变化
UPDATE products
SET stock = stock - 1,
    price = 7899.00
WHERE id = 1 
AND update_time = '2023-11-01 10:00:00';

-- 第三步：验证是否更新成功
SELECT ROW_COUNT(); -- 返回1表示成功，0表示时间戳已变(冲突)，更新失败。
```

一言以蔽之，**悲观锁**就是在读取或操作数据前就先加锁，**乐观锁**不加数据库锁，但是需要在操作前记录“版本标记”或“时间戳”，更新时校验该标记是否改变，从而避免并发写冲突。

那它到底是怎么做到读--写不用加锁的**，快照读和当前读**是指什么？我们后面都会学到。

### 1.5.1.MVCC原理

#### 1.5.1.1.复习事务隔离级别

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/6a7f761e85854fc0a252a476f20f8235.png" alt="image.png" style="zoom:50%;" />

MySQL在`REPEATABLE READ`隔离级别下，是可以**很大程度避免幻读**问题的发生的（**好像解决了，但是又没完全解决**），MySQL是怎么做到的？

#### 1.5.1.2.版本链

**版本链** 是 InnoDB 中用于保存**一行数据多个历史版本**的结构，它是通过 **undo log  +  roll_pointer** 构建起来的一个**链表**结构。

每次一条记录被修改时：注意要修改（只有**更新和删除**操作会生成版本链。删除一条记录时，记录并不会被立即物理删除，而是打上一个标记（标记为 "已删除"）。）

1. 会生成一个 **undo log**（也叫“旧版本”，日志）
2. 在当前记录中保留一个 **roll_pointer** 指针，指向这个 **undo log**
3. 多次修改后，会形成一个**版本链**（多个版本一个接一个）

```sql
最新记录：
+----------------+-----------+----------------+
| name = '张三'  | trx_id=105| roll_pointer → |
+----------------+-----------+----------------+
                    ↓
             Undo Log #1
             name = '李四', trx_id=101, roll_pointer →
                    ↓
             Undo Log #2
             name = '王五', trx_id=100, roll_pointer = null
```

这个链的含义是：

- 最新版本（张三）由事务 `105` 写入
- 上一个版本（李四）由事务 `101` 写入
- 再上一个版本（王五）由事务 `100` 写入
- 每个版本通过 `roll_pointer` 串起来，形成链表结构

**必须要知道的概念（每个版本链针对的一条数据）：**

我们知道，对于使用InnoDB存储引擎的表来说，它的**聚簇索引记录中都包含两个必要的隐藏列：**

（**row_id并不是必要的**，我们创建的表中**存在主键或者UNIQUE键是NOT NULL时都不会包含row_id列。**）

- **trx_id**：每次一个事务对某条聚簇索引记录进行改动时，都会把**该事务的事务id**赋值给trx_id隐藏列。

- **roll_pointer**：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后**这个隐藏列就相当于一个指针**，可以通过它来找到该记录修改前的信息。

补充点：

**Undo Log（回滚日志）：**日志是在对数据执行**增、删、改**操作前，**用来记录数据被修改前的旧值**，这样如果事务回滚，就能用这些日志将数据恢复成之前的状态。

解释：为了实现事务的原子性，InnoDB存储引擎在实际进行增、删、改一条记录时，都需要先把对应的undo日志记下来。**一般每对一条记录做一次改动，就对应着一条undo日志**，但在某些更新记录的操作中，也可能会对应着2条undo日志。一个事务在执行过程中可能新增、删除、更新若干条记录，也就是说需要记录很多条对应的undo日志，**这些undo日志会被从0开始编号**，也就是说根据生成的顺序分别被称为第0号undo日志、第1号undo日志、...、第n号undo日志等，这个编号也被称之为**undo no**。

为了说明这个问题，我们创建一个演示表

```sql
CREATE TABLE teacher (
    number INT,
    name VARCHAR(100),
    domain varchar(100),
    PRIMARY KEY (number)
) Engine=InnoDB CHARSET=utf8;
```

然后向这个表里插入一条数据：

```sql
INSERT INTO teacher VALUES(1, '李瑾', 'JVM系列');
```

现在表里的数据就是这样的：

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/2ab2e19d985e462e87c1b6e7c50ebc5a.png" alt="image.png" style="zoom:80%;" />

假设插入该记录的**事务id为60**，那么此刻该条记录的示意图如下所示：

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/c7b3d5e8c3bd4d91942b0891b0db0956.png" alt="image.png" style="zoom:80%;" />

假设之后两个事务id分别为80、120的事务对这条记录进行UPDATE操作，操作流程如下：

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/85471f9eaddf4d42a51259b6878056ed.png" alt="image.png" style="zoom:80%;" />

**每次对记录进行改动，都会记录一条undo日志**，每条undo日志也都有一个roll_pointer属性（**INSERT操作对应的undo日志没有该属性**，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表，所以现在的情况就像下图一样：

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/c7dc3b48519b4961b04e03594ee80538.png" alt="image.png" style="zoom:80%;" />

对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，**版本链的头节点就是当前记录最新的值**。另外，**每个版本中还包含生成该版本时对应的事务id**。**于是可以利用这个记录的版本链来控制并发事务访问相同记录的行为，那么这种机制就被称之为多版本并发控制(Mulit-Version Concurrency Control MVCC)。**

#### 1.5.1.3.ReadView

Read View就是事务进行 **快照读** 操作的时候生产的**读视图(Read View)**，在该事务**执行快照读的那一刻**，会生成数据库系统当前的一个快照，记录并维护系统当前**活跃事务的ID**(当每个事务开启时，都会被分配一个ID，这个ID是递增的，所以越是最新的事务，ID值越大)

📦 ReadView 是什么时候创建的？

- **在执行快照读语句的“第一次”**，InnoDB 会创建一个 ReadView。
- 也就是说，`START TRANSACTION` 并不会马上创建 ReadView，直到你执行第一个 **普通 SELECT 查询** 时才生成。
- **同一个事务**里创建的 ReadView 是 **唯一的**，贯穿事务生命周期，**直到提交。**

**必须要知道的概念（作用于SQL查询语句）**

对于使用`READ UNCOMMITTED`隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了（**所以就会出现脏读、不可重复读、幻读**）。

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/5e3918aac91a4ee8b6a2de3011021922.png" alt="image.png" style="zoom: 50%;" />

对于使用`SERIALIZABLE`隔离级别的事务来说，InnoDB使用加锁的方式来访问记录（**也就是所有的事务都是串行的，当然不会出现脏读、不可重复读、幻读**）。

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/82450615bb5b4612aaccdd7008280f5e.png" alt="image.png" style="zoom: 50%;" />

对于使用`READ COMMITTED`和`REPEATABLE READ`隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，**核心问题就是：READ COMMITTED和REPEATABLE READ隔离级别在不可重复读和幻读上的区别是从哪里来的？**其实结合前面的知识，这两种隔离级别关键**是需要判断一下版本链中的哪个版本是当前事务可见的**。



**为此，InnoDB提出了一个ReadView的概念（作用于SQL查询语句），**这个ReadView中主要包含4个比较重要的（字段）内容：

- **m_ids：**表示在**生成ReadView时**当前系统中**活跃的读写事务的事务id列表（也成为不可见列表）。**
- **min_trx_id：**表示在生成ReadView时当前系统中**活跃的读写事务中最小的事务id**，也就是m_ids中的最小值。
- **max_trx_id：**表示生成ReadView时系统中**应该分配给下一个事务的id值**。注意**max_trx_id并不是m_ids中的最大值**，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。
- **creator_trx_id：**表示**生成该ReadView的事务的事务id。**

亦可以如下图：

![img](https://oss-cdn.mashibing.com/qa/854f524f523934612a0b21b52ecf83e2.png)

总结：

```go
ReadView {
  m_ids           // 当前系统中 活跃未提交的事务ID列表
  min_trx_id      // m_ids 中的最小事务ID
  max_trx_id      // 创建 ReadView 时，系统中尚未分配的事务ID（全局最大的事务ID + 1）
  creator_trx_id  // 创建该 ReadView 的当前事务ID
}
```

#### 1.5.1.4.READ COMMITTED（已提交读）

##### 脏读问题的解决

READ COMMITTED隔离级别的事务在**每次查询开始时都会生成一个独立的ReadView。**

在MySQL中，READ COMMITTED和REPEATABLE READ隔离级别的的一个非常大的区别就是它们**生成ReadView的时机不同。**

我们还是以表 teacher 为例，**假设现在表teacher 中只有一条由事务id为60的事务插入的一条记录**，接下来看一下READ COMMITTED和REPEATABLE READ所谓的生成ReadView的时机不同到底不同在哪里。
**READ COMMITTED —— 每次读取数据前都生成一个ReadView**

比方说现在系统里有两个事务id分别为80，120的事务在执行（未提交）：见往下第三张图

**Transaction 80执行：**

```sql
UPDATE teacher SET name = '马' WHERE number = 1;
UPDATE teacher SET name = '连' WHERE number = 1;
...
```

此刻，表teacher中number为1的记录得到的版本链表如下所示：

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/bd1d16d019c9405ab12fca214e271053.png" alt="image.png" style="zoom:80%;" />

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/ce38f77cc7814319b8b8b8e6bf1c7997.png" alt="image.png" style="zoom:80%;" />

假设现在有一个使用READ COMMITTED隔离级别的事务开始执行：

```sql
-- 使用READ COMMITTED隔离级别的事务
BEGIN;
-- SELECT1:Transaction 注意此时80、120未提交
SELECT * FROM teacher WHERE number = 1; # 得到的列name的值为'李瑾'
```

**第1次select**的时间点 如下图：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1653285598056/2cb53fc2abf649ab88804b8bc4054127.png)



这个SELECT1的执行过程如下，在执行SELECT语句时会**先生成一个ReadView**：

**ReadView的m_ids列表的内容就是[80, 120]**，**这就是他维护的不可见列表**（**也称活跃事务列表**）：**min_trx_id为80，max_trx_id为121，creator_trx_id为0**

> 这里是做的一个假设。`creator_trx_id` 会被设置为0，表示该操作不是在一个事务中执行的。

然后从版本链中挑选可见的记录，**用当前页面记录的trx_id属性值和m_ids中的进行比较**，从图中可以看出，最新版本的列name的内容是'**连**'，**该版本的trx_id值为80**（即当前这行数据的最新版本的事务id，不管提交没提交），在m_ids列表内，所以不符合可见性要求，

（**trx_id属性值在ReadView的min_trx_id和max_trx_id之间说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问**；**如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问**），

根据**roll_pointer（回滚指针）**跳到下一个版本。
下一个版本的列name的内容是'**马**'，该版本的trx_id值也为80，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。
下一个版本的列name的内容是'**李瑾**'，该版本的trx_id值为60，小于ReadView中的min_trx_id值，所以这个版本是符合要求的，**最后返回给用户的版本就是这条列name为'李瑾'的记录。**



🔄 可见性判断规则（核心逻辑）

InnoDB 会根据**记录上的 `trx_id`** 和当前 ReadView 判断这个记录版本是否“可见”：

✅ 可见的情况：

1. `trx_id < min_trx_id`
    → 写这条记录的事务比所有活跃事务都早，**已经提交** → 可见
2. `trx_id == creator_trx_id`
    → 是自己事务写的版本 → 可见

❌ 不可见的情况：

1. `trx_id ∈ m_ids`
    → 该记录由其他未提交事务创建 → 不可见
2. `trx_id ≥ max_trx_id`
    → 该记录是创建 ReadView 之后的新事务写的 → 不可见

**🔗 ReadView 与 版本链（Version Chain）**

每条记录在被更新时，InnoDB 不会直接覆盖原始数据，而是：

- 保留一条旧版本在 Undo Log 中
- 用 `roll_pointer` 指向上一个版本 → 形成一条 **版本链**

当一个事务通过 ReadView 判断出当前版本不可见，就会顺着版本链**向前找老版本**，直到找到一个**可见版本**或没有更多版本。

**🧪 举个例子：可见性判断实战**

假设现在系统的**全局事务ID**分配到 105，当前活跃事务 m_ids = [100, 102, 104]，那么：

| ReadView字段   | 值        |
| -------------- | --------- |
| min_trx_id     | 100       |
| max_trx_id     | 106       |
| creator_trx_id | 假如是107 |

来看几种版本：

| 记录的版本 trx_id | 是否可见 | 原因                         |
| ----------------- | -------- | ---------------------------- |
| 95                | ✅        | 小于 `min_trx_id`，已提交    |
| 102               | ❌        | 属于活跃事务 m_ids 中        |
| 106               | ❌        | 比 `max_trx_id` 大，后来事务 |
| 107               | ✅        | 自己事务写的                 |

------

**🔐 ReadView 与隔离级别的关系**

| 隔离级别                | 是否用到 ReadView           | 快照是否固定？ |
| ----------------------- | --------------------------- | -------------- |
| READ UNCOMMITTED        | ❌（可以看到未提交）         | 无             |
| READ COMMITTED          | ✅ 每次查询都创建新 ReadView | ❗非固定        |
| REPEATABLE READ（默认） | ✅ 事务内只创建一次          | ✅ 固定         |
| SERIALIZABLE            | ✅（但加锁方式不同）         | ✅              |

> 所以：Repeatable Read 下的快照是一致的，而 Read Committed 每次读取都可能看到不同数据**。**

------

**📝 总结：一句话记住 ReadView**

> **ReadView 是你事务的“快照眼镜”，决定你能看到哪些版本的记录，帮你避开未提交的变动，从而保证一致性。**



**快照读（Snapshot Read）就是不加锁地读取一份数据在某一时刻的一致性“快照”**，即读取的是某个历史版本，而不一定是当前最新写入的版本。

**🧪 举个例子你秒懂：**

假设你现在执行了：

```sql
START TRANSACTION;
SELECT * FROM orders WHERE id = 1;
```

这个 `SELECT` 是一个 **快照读**，它不会看到**其他事务尚未提交的更改**，只会看到事务开始那一刻“数据在你眼中”的样子。

即便其他事务后来改了 `orders.id = 1` 的记录，你这个事务还是看到当时的版本 —— 就像你“戴上了一副快照眼镜”。

**💡 快照读的特点：**

| 特性             | 说明                                       |
| ---------------- | ------------------------------------------ |
| 不加锁           | 快照读 **不会加锁**，所以并发性能高        |
| 读取的是历史版本 | 使用 Undo Log 回溯数据形成“旧版本”         |
| 与 MVCC 密切相关 | 基于 Undo Log + ReadView 实现              |
| 只用于“非锁定读” | 只在 **普通 SELECT** 中使用（不加 `LOCK`） |

（接上面）**所以有了这种机制，就不会发生脏读问题！因为会去判断活跃版本，必须是不在活跃版本的才能用，不可能读到没有 commit的记录。**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1653285598056/dd356cf81ec14665b7f11c82ec6021e9.png)

**总结：**

📌 关键点：**READ COMMITTED只能读取“已提交”事务的数据**

在 **READ COMMITTED 隔离级别下**：

- 每次 `SELECT` 都会创建一个新的 **ReadView**
- 这个 ReadView 只会让你看到 **已经提交的版本**
- 未提交的数据**根本不对你可见**

##### 不可重复读问题

然后，我们把事务id为80的事务**提交**一下，然后再到事务id为120的事务中更新一下表teacher 中number为1的记录：

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/352c5da6030041ef820ba4408c670362.png" alt="image.png" style="zoom: 67%;" />

```sql
Transaction120
BEGIN;
更新了一些别的表的记录
UPDATE teacher  SET name = '严' WHERE number = 1;
UPDATE teacher  SET name = '晁' WHERE number = 1;
```

此刻，表teacher 中 number为1的记录的版本链就长这样：

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/7202b4c9114b440f9473bcfe9699ab74.png" alt="image.png" style="zoom:80%;" />

然后再到刚才使用READ COMMITTED隔离级别的事务中继续查找这个number为1的记录，如下：

使用READ COMMITTED隔离级别的事务

```sql
BEGIN;

SELECE1: Transaction 80、120均未提交

SELECT * FROM teacher WHERE number = 1; # 得到的列name的值为'李瑾'

SELECE2：Transaction 80提交，Transaction 120未提交

SELECT * FROM teacher WHERE number = 1; # 得到的列name的值为'连'

```

**第2次select的时间点 如下图：**

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1653285598056/076acec8fbe7463cb9f2f709327cdfb5.png" alt="image.png" style="zoom: 80%;" />

这个SELECE2的执行过程如下：

```SQL
SELECT * FROM teacher WHERE number = 1;
```

**在执行SELECT语句时会又会单独生成一个ReadView**（重要），该ReadView信息如下：

**m_ids列表的内容就是[120]（事务id为80的那个事务已经提交了，所以再次生成快照时就没有它了），min_trx_id为120，max_trx_id为121，creator_trx_id为0（？）。**
然后从版本链中挑选可见的记录，从图中可以看出：

- 最新版本的列name的内容是'**晁**'，该版本的trx_id值为120，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。
- 下一个版本的列name的内容是'**严**'，该版本的trx_id值为120，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。
- 下一个版本的列name的内容是'**连**'，该版本的trx_id值为80，小于ReadView中的min_trx_id值120，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为'**连**'的记录。

以此类推，如果之后事务id为120的记录也提交了，再次在使用READ COMMITTED隔离级别的事务中查询表teacher 中number值为1的记录时，得到的结果就是'**晁**'了，具体流程我们就不分析了。

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1653285598056/e183bd95aed6411aba3ded451871dbff.png" alt="image.png" style="zoom: 80%;" />


##### 但会出现不可重复读问题。

明显上面一个事务中两次

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1653285598056/b1232c1150a646eda0637a914716e0fc.png)

总结：

在 READ COMMITTED 隔离级别下：

> 每一次 `SELECT` 查询，**都会创建一个新的 ReadView（快照）**！

也就是说：

- 第一次读数据，创建一个快照1（ReadView1）
- 第二次读数据，又重新创建快照2（ReadView2）
- 你两次读的数据，其**“可见性判断标准”**变了！上面的可见性从[80, 120]变成了[120]

简而言之，在 READ COMMITTED 下，每次读都会创建一个新的 ReadView，能看到**其他已提交事务的新数据**，所以可能出现**不可重复读**。

#### 1.5.1.5.REPEATABLE READ（可重复读）

##### REPEATABLE READ解决不可重复读问题

✅ 核心机制：**一个事务只生成一次 ReadView，一直复用！**

也就是说：

- 在一个事务中，第一次执行“快照读”时（也就是查询操作，不加锁），生成一个 **ReadView（快照）**
- 在整个事务期间，这个 ReadView **不会变**
- 所有的快照读，**都基于这个固定的视角去看数据**
- 所以就算其他事务提交了数据，在你眼里还是“不可见”

举例：

**初始数据**

```sql
id = 1, name = 'Alice'
```

**事务A：**

```sql
START TRANSACTION;
-- 第一次查询
SELECT name FROM users WHERE id = 1;   -- 结果：Alice
```

这时生成了一个 ReadView，记录下当前的**活跃事务 ID 列表**（m_ids）

**此时，事务B 修改并提交：**

```sql
START TRANSACTION;
UPDATE users SET name = 'Bob' WHERE id = 1;
COMMIT;
```

**回到事务A：**

```sql
-- 第二次查询
SELECT name FROM users WHERE id = 1;   -- 结果：还是 Alice
```

> 因为事务A使用的是 **第一次生成的 ReadView**，事务B的修改在这视角中是“不可见的”，所以事务A看不到它。

**✅ 所以，REPEATABLE READ 可以做到：**

> 同一个事务中，**多次读取相同数据结果一致**，从而✅解决了不可重复读问题。



`REPEATABLE READ` —— **在第一次读取数据时生成一个ReadView**

对于使用REPEATABLE READ隔离级别的事务来说，**只会在第一次执行查询语句时生成一个ReadView**，之后的查询就不会重复生成了。我们还是用例子看一下是什么效果。

比方说现在系统里有两个事务id分别为80，120的事务在执行：Transaction 80

```sql
UPDATE teacher  SET name = '马' WHERE number = 1;
UPDATE teacher  SET name = '连' WHERE number = 1;
...
```

此刻，表teacher 中number为1的记录得到的版本链表如下所示：

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/bd1d16d019c9405ab12fca214e271053.png" alt="image.png" style="zoom:80%;" />

假设现在有一个使用`REPEATABLE READ`隔离级别的事务开始执行：

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/ce38f77cc7814319b8b8b8e6bf1c7997.png" alt="image.png" style="zoom:80%;" />

```sql
-- 使用READ COMMITTED隔离级别的事务
BEGIN;
-- SELECT1：Transaction 80、120未提交
SELECT * FROM teacher WHERE number = 1; # 得到的列name的值为'李瑾'
```

- **这个SELECE1的执行过程如下：**

在执行SELECT语句时会先生成一个ReadView：和前面的RC过程一样。

ReadView的m_ids列表（活跃事务列表）的内容就是[80, 120]，min_trx_id为80，max_trx_id为121，creator_trx_id为0。

然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是'**连**'，该版本（即这行数据当前的最新版本）的trx_id值为80，在m_ids列表内，所以不符合可见性要求（trx_id属性值在ReadView的min_trx_id和max_trx_id之间说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问），根据roll_pointer跳到下一个版本。
下一个版本的列name的内容是'**马**'，该版本的trx_id值也为80，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。
下一个版本的列name的内容是'**李瑾**'，该版本的trx_id值为60，小于ReadView中的min_trx_id值，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为'**李瑾**'的记录。
**之后，我们把事务id为80的事务提交一下**，然后再到事务id为120的事务中更新一下表teacher 中number为1的记录：

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/352c5da6030041ef820ba4408c670362.png" alt="image.png" style="zoom:67%;" />

```sql
Transaction120
BEGIN;
-- 更新了一些别的表的记录
UPDATE teacher  SET name = '严' WHERE number = 1;
UPDATE teacher  SET name = '晁' WHERE number = 1;
```

此刻，表teacher 中number为1的记录的版本链就长这样：

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/7202b4c9114b440f9473bcfe9699ab74.png" alt="image.png" style="zoom:67%;" />

然后再到刚才使用REPEATABLE READ隔离级别的事务中继续查找这个number为1的记录，如下：

使用READ COMMITTED隔离级别的事务

```sql
BEGIN;
-- SELECT1：Transaction 80、120均未提交
SELECT * FROM teacher WHERE number = 1; # 得到的列name的值为'李瑾'
-- SELECT2：Transaction 80提交，Transaction 120未提交
SELECT * FROM teacher WHERE number = 1; # 得到的列name的值还是为'李瑾'
```

- 这个SELECE2的执行过程如下：

> 注意：**重点在于复用之前的Read View。**这是因为SELECT1和SELECT2在同一个事务里面，所以才能共用同一个Read View。


因为当前事务的隔离级别为REPEATABLE READ，而之前在执行**SELECE1时已经生成过ReadView**了，所以在SELECE2时**直接复用之前的ReadView**，之前的ReadView的m_ids列表的内容就是[80, 120]，min_trx_id为80，max_trx_id为121，creator_trx_id为0。

**根据前面的分析，返回的值还是'李瑾'。**

**也就是说两次SELECT查询得到的结果是重复的，记录的列name值都是'李瑾'，这就是可重复读的含义。**

**📌 总结一句话：**

> **REPEATABLE READ 通过生成一次 ReadView 并在整个事务期间复用，屏蔽了其他事务在这期间提交的变更，从而避免不可重复读。**

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/64659425cf56414fba3a80c42c0538b7.png" alt="image.png" style="zoom:80%;" />

**总结一下就是：**

**ReadView中的比较规则(前两条)**

1. 如果被访问版本的**trx_id属性值与ReadView中的creator_trx_id值相同**，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
2. 如果被访问版本的**trx_id属性值小于ReadView中的min_trx_id值**，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。

#### 1.5.1.6.MVCC下的幻读解决和幻读现象

前面我们已经知道了，REPEATABLE READ隔离级别下MVCC可以解决不可重复读问题，那么幻读呢？MVCC是怎么解决的？幻读是一个事务按照某个相同条件多次读取记录时，**后读取时读到了之前没有读到的记录，而这个记录来自另一个事务添加的新记录。**

我们可以想想，在`REPEATABLE READ`隔离级别下：

- 事务T1先根据某个搜索条件读取到多条记录，

- 然后事务T2插入一条符合相应搜索条件的记录**并提交**，

- 然后事务T1再根据相同搜索条件执行查询。结果会是什么？按照**ReadView中的比较规则(后两条)：**

  - 如果被访问版本的trx_id属性值大于或等于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。

  - 如果被访问版本的trx_id属性值是否在ReadView的min_trx_id和max_trx_id之间(min_trx_id &#x3c; trx_id &#x3c; max_trx_id)，也就是需要判断一下trx_id属性值是不是在m_ids列表中，
    - 如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；
    - 如果不在（小于min_trx_id），说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。

不管事务T2比事务T1是否先开启，事务T1都是看不到T2的提交的。请自行按照上面介绍的版本链、ReadView以及判断可见性的规则来分析一下。
但是，在REPEATABLE READ隔离级别下InnoDB中的MVCC **可以很大程度地避免幻读现象，而不是完全禁止幻读。**怎么回事呢？我们来看下面的情况：

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/00b3c1b4774c47cb9a2ceb19d921b504.png" alt="image.png" style="zoom:80%;" />

我们首先在事务T1中：

```sql
select * from teacher where number = 30;
```

很明显，这个时候是找不到number = 30的记录的。
我们在事务T2中，执行：

```sql
insert into teacher values(30,'豹','数据湖');
```

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/f1935b415db04ac482e023c6406f8de3.png)

通过执行`insert into teacher values(30,'豹','数据湖')`;，我们往表中插入了一条number = 30的记录。
此时回到事务T1，执行：

```sql
update teacher set domain='RocketMQ' where number = 30; -- 间隙锁？？？？
select * from teacher where number = 30;
```

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/7ca9e16a31d84d5ca72fdb236a95eb28.png" alt="image.png" style="zoom:80%;" />

嗯，怎么回事？事务T1很明显出现了幻读现象（这不是很正常吗？）。在REPEATABLE READ隔离级别下，

- T1第一次执行普通的SELECT 语句时生成了一个ReadView（但是版本链没有变化，因为没有update操作），

- 之后T2向teacher 表中新插入一条记录并提交，
- 然后T1也进行了一个update语句。

ReadView并不能阻止T1执行UPDATE 或者DELETE 语句来改动这个新插入的记录，**但是这样一来，这条新记录的trx_id隐藏列的值就变成了T1的事务id。**

总结：通过UPDATE 或者DELETE 语句，间接解决了幻读？？？

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1653285598056/92d29ec669db40b1a07fb0b3cc8cb730.png" alt="image.png" style="zoom:80%;" />

之后T1再使用普通的SELECT 语句去查询这条记录时就可以看到这条记录了，也就可以把这条记录返回给客户端。因为这个特殊现象的存在，我们也可以认为MVCC 并不能完全禁止幻读（**就是第一次读如果是空的情况，且在自己事务中进行了该条数据的修改**）。

以上例子是说明不能完全解决幻读，不是为了说明能解决幻读

#### 1.5.1.7.MVCC小结

从上边的描述中我们可以看出来，所谓的**MVCC**（Multi-Version Concurrency Control ，多版本并发控制）**指的就是在使用`READ COMMITTD`、`REPEATABLE READ`这两种隔离级别的事务在执行普通的SELECT操作时访问记录的版本链的过程**，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。

READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是：生成ReadView的时机不同

- READ COMMITTD在**每一次**进行普通SELECT操作前都会生成一个ReadView，

- 而REPEATABLE READ只在**第一次**进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了，从而基本上可以避免幻读现象（**就是第一次读如果ReadView是空的情况中的某些情况则避免不了**）。

另外，**所谓的MVCC只是在我们进行普通的SEELCT查询时（快照读）才生效**，截止到目前我们所见的所有SELECT语句都算是普通的查询，至于什么是个不普通的查询，后面马上就会讲到（**锁定读**）。
