/*
第一题

package main

import "fmt"

// 已知数组 A, B, 如果 A 中元素在 B 数组存在，打印出这个元素的下标，B 数组是不重复的.
// Input: [5, 3, 1, 5, 4] [5, 3]
// Output: [0, 1, 3]

func main() {
  a := []int{5, 3, 1, 5, 4}
  b := []int{5, 3}
  fmt.Println(a)
  fmt.Println(b)
}


第二题

package main

import "fmt"

// 现在数据库有一张表，用来存储一个多叉树，id为主键，pid 表示父节点的 id，已知 "-1" 表示根节点，现在要求打印出从根节点到每个子节点的路径（可以是无序的）。
// 注意： 是所有节点的路径，非叶子结点
//
// | id      | pid    |
// |---------|--------|
// | "A"     | "-1"   |
// | "A-1"   | "A"    |
// | "A-2"   | "A"    |
// | "A-3"   | "A"    |
// | "A-2-1" | "A-2"  |
// | "A-2-2" | "A-2"  |
// | "A-2-3" | "A-2"  |
//
// Input: [
//   {
//       "id": "A",
//       "pid": "-1"
//   },
//   {
//       "id": "A-1",
//       "pid": "A"
//   },
//   {
//       "id": "A-2",
//       "pid": "A"
//   },
//   {
//       "id": "A-3",
//       "pid": "A"
//   },
//   {
//       "id": "A-2-1",
//       "pid": "A-2"
//   },
//   {
//       "id": "A-2-2",
//       "pid": "A-2"
//   },
//   {
//       "id": "A-2-3",
//       "pid": "A-2"
//   }
// ]
// Output: [
//   "/A",
//   "/A/A-1",
//   "/A/A-2",
//   "/A/A-3",
//   "/A/A-2/A-2-1",
//   "/A/A-2/A-2-2",
//   "/A/A-2/A-2-3",
// ]

type Node struct {
    ID  string
    PID string
}

func main() {
    nodes := []Node{
       {
          "A",
          "-1",
       },
       {
          "A-1",
          "A",
       },
       {
          "A-2",
          "A",
       },
       {
          "A-3",
          "A",
       },
       {
          "A-2-1",
          "A-2",
       },
       {
          "A-2-2",
          "A-2",
       },
       {
          "A-2-3",
          "A-2",
       },
    }

    fmt.Println(nodes)
}


第三题
package main

import (
    "fmt"
)

// 从上到下找到最短路径（n个数字之和最小,n为矩阵的行数），可以从第一行中的任何元素开始，只能往下层走，同时只能走向相邻的节点，例如图中第一排 2 只能走向 第二排的 7、3；第二排的 7 可以走向第三排的 6、2、9
//
// | 5    | 8    | 1    | 2    |
// | 4    | 1    | 7    | 3    |
// | 3    | 6    | 2    | 9    |
//
// Input: [
//     [5, 8, 1, 2],
//     [4, 1, 7, 3],
//     [3, 6, 2, 9]
// ]
// Output: 4

func main() {
    matrix := [][]int{
       {5, 8, 1, 2},
       {4, 1, 7, 3},
       {3, 6, 2, 9},
    }
    fmt.Println(matrix)
}



第四题

package main

import (
    "fmt"
)

// 有一个字符串数组，每个字符串都只包含小写字母，现在需要找到两个长度相乘最大的字符串，并且两个字符串不能有相同的字母，如果没有满足这个条件的结果，返回0
//
// Input: ["abcw","baz","foo","bar","xtfn","abcdef","jk"]
// Output: 16
//
// Input: ["a","aa","aaa","aaaa"]
// Output: 0

func main() {
    s := []string{"abcw", "baz", "foo", "bar", "xtfn", "abcdef", "jk"}
    fmt.Println(s)
}

*/