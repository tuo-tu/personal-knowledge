# 模糊测试 Fuzzing

go test 支持单元测试和基准测试，1.18是增加了模糊测试。

## 单元测试

单元测试，unit test，主要用以测试函数是否完成某项功能。示例如下：

功能代码示例：

```go
func Add(a, b uint8) uint8 {
	return a + b
}
```

单元测试代码：

```go
# _test.go
func TestAdd(t *testing.T) {
	type item struct {
		a, b, s uint8
	}
	items := []item{
		{1, 1, 2},
		{10, 56, 66},
		{100, 101, 201},
		{123, 1, 124},
	}

	for _, v := range items {
		s := Add(v.a, v.b)
		if s != v.s {
			t.Errorf("a: %d, b: %d, s: %d", v.a, v.b, s)
		}
	}
}
```

运行单元测试：

```shell
> go test -run TestAdd -v
=== RUN   TestAdd
--- PASS: TestAdd (0.00s)
PASS
ok      github.com/han-joker/goExample/generalType      0.029s

```

单元测试的局限性：

测试用例完全需要用户编写，若想完成用例覆盖，则需要大量的测试用例编写。

## 模糊测试

模糊测试的核心思想是**向程序输入随机生成或变异的数据**，试图触发程序中的错误、崩溃或安全漏洞。

Go 1.18在go工具链里引入了**fuzzing模糊测试**，可以帮助我们发现Go代码里的漏洞或者可能导致程序崩溃的输入。

模糊测试的核心特征，是可以**自动随机生成大量的测试用例，用于保证覆盖大量的数据场景。**

### 使用方法

语法特点：

- 位于*_test.go 中
- 测试函数以Fuzz开头
- 测试函数参数为 `*testing.F`类型（还有其他参数）

`*testing.F`的典型方法：

- f.Add()，将特定数据作为种子加入到测试用例中，**种子数据类型要与测试数据函数的类型一致**
- f.Fuzz()，**用于完成模糊测试，需要提供测试函数**，典型的测试函数以***testing.T为第一个参数，测试用例数据为后续参数**

```go
func (f *F) Fuzz(ff any)
```

运行模糊测试：

- go test，会自动执行Test和Fuzz开头的单元和模糊测试
- go test -run Pattern，仅执行匹配Pattern的测试
- go test -fuzz Pattern, 仅执行匹配Pattern的Fuzz。**Fuzz就是随机生成测试模糊数据。不带-fuzz不会模糊测试**
- go test --fuzztime 3s，指定fuzz测试时间，默认会一直执行到错误发生

`Add` 方法的主要功能是将用户提供的测试用例添加到模糊测试的**种子语料库中**，以便模糊测试引擎可以以这些种子为基础生成更多随机测试用例。**种子语料库**（Seed Corpus）是模糊测试（Fuzz Testing）中**用于生成测试输入数据的初始集合**。

- **`os.O_CREATE`**：如果文件不存在，则创建文件。
- **`os.O_TRUNC`**：如果文件已存在，则清空文件内容。
- **`0644`**：设置文件权限，表示**文件所有者可以读写，其他人只能读取。**

示例：

```go
// 定义Add的模糊测试函数
func FuzzAdd(f *testing.F) {
	// 一、添加测试用例种子到模糊测试的语料库中，值类型要与测试函数Add保持一致，具体的值随意
	f.Add(uint8(2), uint8(3))
	// 额外：创建一个文件，将生成的模糊测试用例，写入到文件中
	file, _ := os.OpenFile("./fuzz_input.txt", os.O_CREATE|os.O_TRUNC, 0644)
	defer file.Close()
	// 二、执行测试，基于种子生成的模糊数据完成测试
	f.Fuzz(func(t *testing.T, a, b uint8) {
		// 将模糊测试过程中生成的输入值（a，b的值）写入日志文件
		fmt.Fprintf(file, "a:%d, b:%d\n", a, b)
		s := Add(a, b)
		// 模糊测试，由于数据随机生成，因此结果也是随机的
		// 重点：必须要找到可以判定是否结果正确的方法。
		if s-a != b {
			t.Errorf("a: %d, b: %d, s: %d", a, b, s)
		}
	})
}
```

注意：不同于单元测试，模糊测试的数据用例是随机的，因此**编写模糊测试我们要找到办法来判定是否成功**。例如本例中，我么可以选择用减法进行运算。**互相可逆的算法，通常用来在模糊测试中检测结果是否正确。**

* 加和减
* 乘和除
* 反转和两次反转
* 布尔值的两次取反运算

上面代码中的./data.txt 文件，与模糊测试无关，是我们用来了解生产的的大量随机数据的。

`t.Errorf` 是 Go 的测试库 `testing` 中提供的方法，用于在测试失败时**报告错误并记录详细信息**。它可以格式化输出错误信息（并将其记录到测试日志中），同时不会中断测试用例的执行（与 `t.Fatalf` 不同）。

如果 `Add(2, 3)` 的返回值不等于 `5`，则 `t.Errorf` 会**记录**错误：

```yaml
--- FAIL: TestAdd (0.00s)
    main_test.go:13: Add(2, 3) failed: expected 5, got 4
```

执行模糊测试：

```shell
> go test -run FuzzAdd -fuzz FuzzAdd -v
=== RUN   FuzzAdd
fuzz: elapsed: 0s, gathering baseline coverage: 0/4 completed
fuzz: elapsed: 0s, gathering baseline coverage: 4/4 completed, now fuzzing with 8 workers
fuzz: elapsed: 3s, execs: 137820 (45936/sec), new interesting: 1 (total: 5)
fuzz: elapsed: 6s, execs: 304346 (55479/sec), new interesting: 1 (total: 5)
fuzz: elapsed: 9s, execs: 539816 (78408/sec), new interesting: 1 (total: 5)
fuzz: elapsed: 12s, execs: 757555 (72595/sec), new interesting: 1 (total: 5)
fuzz: elapsed: 15s, execs: 971940 (71480/sec), new interesting: 1 (total: 5)
fuzz: elapsed: 18s, execs: 1177823 (68413/sec), new interesting: 1 (total: 5)
fuzz: elapsed: 21s, execs: 1370681 (64399/sec), new interesting: 1 (total: 5)
fuzz: elapsed: 24s, execs: 1554033 (61244/sec), new interesting: 1 (total: 5)
fuzz: elapsed: 27s, execs: 1731988 (59167/sec), new interesting: 1 (total: 5)
fuzz: elapsed: 30s, execs: 1888973 (53294/sec), new interesting: 1 (total: 5)
--- PASS: FuzzAdd (29.96s)
=== NAME
PASS
ok      goSyntax        30.011s

```

`fmt.Sprintf` 是 Go 标准库中 `fmt` 包提供的一个函数，**用于格式化字符串并返回格式化后的结果**，而不是直接输出到控制台或文件（与 `fmt.Printf` 不同）。

### 错误处理

更新FuzzAdd，模拟一个错误。

模拟a+b溢出uint8的情景。由于我们之前的单元测试数据没有覆盖可能溢出的场景，我们在模糊测试中，检测这一场景：？

```go
if int(s) != int(a)+int(b) {
    t.Errorf("a: %d, b: %d, s: %d", int(a), int(b), int(s))
}
```

思路就是转换为范围更大的整数，再进行比较。

执行测试：

```shell
> go test -run FuzzAdd -fuzz FuzzAdd -v --fuzztime 3s
=== RUN   FuzzAdd
fuzz: elapsed: 0s, gathering baseline coverage: 0/8 completed
fuzz: elapsed: 0s, gathering baseline coverage: 3/8 completed
--- FAIL: FuzzAdd (0.06s)
    --- FAIL: FuzzAdd (0.00s)
        fuzzing_test.go:53: a: 101, b: 193, s: 38

    Failing input written to testdata\fuzz\FuzzAdd\b57d10201eb5ef68
    To re-run:
    go test -run=FuzzAdd/b57d10201eb5ef68
=== NAME
FAIL
exit status 1
FAIL    goSyntax        0.097s
```

**命令解析：**`go test -run FuzzAdd -fuzz FuzzAdd -v --fuzztime 3s`

- **`go test`**：运行 Go 的测试命令。
- **`-run FuzzAdd`**：筛选运行特定的测试或模糊测试函数，这里选择函数名匹配 `FuzzAdd` 的测试函数。
- **`-fuzz FuzzAdd`**：指定要进行模糊测试的函数，名称需要以 `Fuzz` 开头。
- **`-v`**：启用**详细输出模式**（verbose），会打印更多的日志信息。
- **`--fuzztime 3s`**：设定模糊测试的持续时间为 3 秒。

错误的用例会被记录到：testdata/fuzz/FuzzAdd/ 目录下的文件中。

示例：第一行为版本，后边的每行为一个测试参数，本例中a,b两个参数，因此形成两行：

```
go test fuzz v1
byte(',')
byte('Ü')
```

注意，**该错误数据会被保留**，下次执行FuzzAdd测试时，会自动使用，即使不使用-fuzz参数。这么做的目的是继续检测错误数据是否可以通过。当发现问题后，修复问题即可。

```shell
> go test -run FuzzAdd -v
=== RUN   FuzzAdd
=== RUN   FuzzAdd/seed#0
=== RUN   FuzzAdd/b57d10201eb5ef68
--- PASS: FuzzAdd (0.00s)
    --- PASS: FuzzAdd/seed#0 (0.00s)
    --- PASS: FuzzAdd/b57d10201eb5ef68 (0.00s)
PASS
ok      goSyntax        0.041s
```

### 模糊测试用例种子

**种子的意思，会基于种子数据，生成大量的随机数据**。以字符串为例：

```go
func FuzzSeed(f *testing.F) {
	f.Add("mashibing")
    // 0666 表示文件所有者、组用户、其他用户都拥有读写权限。
	file, _ := os.OpenFile("./dataStr.txt", os.O_CREATE|os.O_TRUNC, 0666)
	defer file.Close()
	f.Fuzz(func(t *testing.T, s string) {
		fmt.Fprintf(file, "%s\n", s)
	})
}
```

执行fuzz：

```shell
go test -run FuzzSeed -fuzz FuzzSeed -v
```

查看datStr.txt文件，检索mashibing，类似的内容如下：

```txt
mashibing��+~�I��g�=
mashigina��b
   �ibing
mashibg
mashibing��+~�I��____g�=
```
