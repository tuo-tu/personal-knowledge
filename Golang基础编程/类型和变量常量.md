# 类型和变量常量

## 概览

应用程序由：

- 数据
- 控制

构成。

“类型，变量和常量”是数据处理的核心结构。

Go 是一种静态的强类型的编程语言，这意味着变量在编译时确定其类型，并始终保持该类型。

* 静态：编译时确定，而不是运行时确定（动态）
* 强类型：变量的类型不可更改。（弱类型，变量的类型可以更改）

支持的类型：

- Boolean types
- Numeric types
  - integer type
  - floating-point type
  - complex type
- String types
- Array types
- Slice types
- Struct types
- Map types
- Pointer types
- Interface types
- Function types
- Channel types

不同类型的值，具备不同的值范围。

值的访问（存储）方式为变量或常量。顾名思义：

- 变量，程序运行中，值可以发生改变的量，var
- 常量，程序运行中，值不可以改变的量，在编译时确定，const

## 常量 Constants

不变的**值**称为常量。

常量支持的类型：

- boolean constants
- string constants
- rune constants
- integer constants
- floating-point constants
- complex constants

其中 Rune, integer, floating-point, 和 complex 类型的常量被统称为数值常量（numeric constants）。

常量在程序中的形式：

- rune, integer, floating-point, imaginary, 或 string 类型的字面量
- 常量标识符
- 常量表达式，仅包含常量运算数的表达式
- 一些内建函数的返回值（速记：内建函数，同时参数是常量，或者说可以在编译时静态确定的）
  - 使用常量参数的 `min`或 `max`
  - 使用字符串常量参数的 `len`
  - 使用数组，或数组指针参数的 `len`和 `cap`,同时要求表达式中不能包含通道接收或非常量函数调用
  - 使用复数常量的 `real`和 `imag`
  - 使用数值常量的 `complex`
  - 使用特定参数的 `unsafe.Sizeof`，特定值不包含那些带有可变尺寸的泛型类型以及包含可变尺寸数组元素或结构体字段
  - 结果为常量的类型转换
- 预定义标识符iota

示例：

```go
// 特定类型字面量
const cr rune = 'G'
const ci int = 42
const cf float64 = 3.14
const cs string = "gopher"
// 常量标识符
const ci2 = ci
// 常量表达式
const cexp = 32 + 10
// 一些内建函数的返回值
// strings.ToLower()
// len()
const cbif = len("gopher")
const cbif1 = len([3]int{1, 2, 3}) // array
//const cbif2 = len([]int{1, 2, 3})  // slice, 不能表示为常量

const (
	c1 = iota
	c2
	c3
	cLen
)
```

### 常量声明

常量声明指的是给一组常量绑定标识符。

声明语法：

```go
const 常量标识符列表 = 表达式列表
const 常量标识符列表 类型 = 表达式列表
const (
    常量标识符列表 = 表达式列表
    常量标识符列表 类型 = 表达式列表
)
```

示例：

```go
// const 常量标识符列表 = 表达式列表
const c1 = 42
const c2, c3 = 365, "go"

// const 常量标识符列表 类型 = 表达式列表
const c4, c5 string = "go", "gopher"

//const (
//	常量标识符列表 = 表达式列表
//	常量标识符列表 类型 = 表达式列表
//)
const (
	c6         = "go"
	c7, c8 int = 42, 365
)
```

括号方案的常量声明，可以省略除第一个常量声明外的全部表达式列表。省略表达式表示与上面最近的未省略表达式保持一致的定义。省略后要保证标识符和表达式数量相同。

```go
const (
    常量标识符列表1 = 表达式列表1 // 不可以省略
    常量标识符列表2 // 后续的可以省略，等同于:常量标识符列表2 = 表达式列表1
)
```

示例：

```go
// 省略声明
const (
	ct1 = "go"
	ct2 // 与上面的声明保持一致
	ct3
)

const (
	cst1 = "go"
	cst2
	cst3 = 42
	cst4
	cst5
)
```

### iota 常量生成器

通常用在const()的常量生成语法中。iota的值为声明行的索引值。

```go
const (
	c0 = iota // iota == 0 
	c1	// iota == 2
)
```

便于生成批量的（相关）常量，示例：

```go
// iota 生成器
const (
	o1 = iota // iota == 0
	o2        // iota == 1
	o3
)

// 二进制单独位为1的常量
const (
	n1 = 1 << iota // iota == 0，n1 == 0b001
	n2             // iota == 1，n2 == 0b010
	n3             // iota == 2，n3 == 0b100
)

const (
	s1 = 42 * iota // iota == 0，n1 == 0b001
	s2             // iota == 1，n2 == 0b010
	s3             // iota == 2，n3 == 0b100
)
```

iota基于常量声明行而递增的，意味着：

* 一行内，多次使用，iota的值是相同的
* 支持匿名标识符跳行

示例：

```go
// 一行内，多次使用，iota的值是相同的
const (
	t1, t2 = iota, iota // 0, 0
	t3, t4
	_, _   // 匿名标识符跳行
	t5, t6 // 3, 3
)
```

### 确定类型和未确定类型常量

常量可以为确定类型（typed）和未确定类型（untyped）的。

常量在如下情况可以确定类型：

- 常量声明
- 类型转换

常量确定类型时，必须要求常量满足相应类型的表示形式。

示例：

```go
// untyped，不能确定42到底是int,uint,int8,uint8,int32,uint32...
const v1 = 42
// typed, 常量声明指定类型
const v2 int = 42
// typed，类型转换
const v3 = int(42)
```

未确定类型常量的形式包括：

- 字面量常量：`"gopher", 3.14, false,'X'`
- true, false
- iota
- 仅包含未确定类型常量的常量表达式

未确定类型常量具有默认类型。当需要确定类型值时，会将未确定类型常量隐式的转换过去。

例如：

- 为变量赋值时
- 作为参数传递时
- 参与表达式运算时

未确定类型常量的默认类型为：

- bool，boolean constants
- rune，rune constants
- int，integer constants
- float64，floating-point constants
- complex128，complex constants
- string，string constants

示例：

```go
// 为变量赋值时，会隐式的转换
var i1 int = v1
var i2 uint = v1
var i3 int8 = v1
var i4 uint64 = v1

// 默认类型
var i5 = v1 // integer类型（全部的整型）的默认类型为int
var i6 = 42 // untyped int, default type is int
```

### 数值常量的精度

由于数值常量可表示任意精度的精确值，并且不会溢出。因此，没有表示 IEEE-754 负零值、无穷大和非数字值的常数。

实现限制：尽管数值常量在语言中具有任意精度，但编译器可以使用精度有限的内部表示来实现它们。也就是说，每个实现都必须：

- 表示至少 256 位的整数常量
- 表示浮点常量，包括复数常量的各个部分，尾数至少为 256 位，有符号二进制指数至少为 16 位
- 如果无法精确表示整数常量，则给出错误
- 如果由于溢出而无法表示浮点或复常数，则给出错误
- 如果由于精度限制而无法表示浮点或复常数，则舍入到最接近的可表示常量

示例：

```go
const pi = 3.14
const pi1 = 3.1415926
const pi2 = 3.14159265358979323846264338327950288419716939937510
const i1 = 123456789012345678901234567890123457890
```

### 常量小结

* const 关键字声明
* iota可以生成序列化的常量
* 仅支持几个基础类型的常量
* 常量指的是值不可变
* 常量声明指的是绑定标识符到常量值，而不是典型意义的声明一个常量
* 常量有确定类型和未确定类型之分，未确定类型的常量在需要类型的环境中，会转换为默认类型，除非强制转换

## 变量 Variables

变量是用于保存值的**存储位置**。意味着**变量可以寻址**（&，取地址操作符）。

变量可用的值取决于其类型。

变量需要先声明后使用，声明时需确定其类型，并初始化。

> **为什么要有变量？**
>
> 程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。

哪里会声明变量？

- 变量声明
- 函数声明中的具名参数和具名返回值

示例：

```go
// 变量的声明语句
var v1 int

func VarDec() {
	// 声明变量
	var v2 int
	v3 := 0
}

// 函数声明中的具名参数和具名返回值
func func1(p1, p2 int) (r1, r2 string) {
	return "", ""
}
```

数组array的元素、切片slice的元素，结构体struct的字段的行为类似于变量。行为主要指的是可以取地址。

示例：

```go
func likeVar() {
	// array
	a := [3]string{"a", "b", "c"}
	// slice
	s := []string{"a", "b", "c"}
	// struct
	stct := struct {
		Field1 string
		Field2 int
	}{
		"Go",
		42,
	}
	// 可以成员取址
	fmt.Println(&a[1], &s[2], &stct.Field2, &a, &s, &stct)

	// map
	m := map[string]int{
		"name": 13,
		"age":  14,
	}
	// 不可以成员取址， error
	fmt.Println(&m["name"])
}
```

额外：

- 变量的内存分配
- 变量的回收

### 变量声明

变量声明用于创建一个或多个变量，为变量绑定标识符，同时设置其类型和初始值。

- 变量需要先声明后使用
- 变量声明后必须要被使用，使用指的是获取变量值

声明语法：

```go
var 变量标识符列表 类型
var 变量标识符列表 = 表达式列表
var 变量标识符列表 类型 = 表达式列表

var(
    变量标识符列表 类型
    变量标识符列表 = 表达式列表
    变量标识符列表 类型 = 表达式列表
)
```

示例：

```go
//var 变量标识符列表 类型
var v1 int     // 0
var v2, v3 int // 0, 0

//var 变量标识符列表 = 表达式列表
var v4 = 42           // int, 42 untyped int constant default type is int
var v5, v6 = "go", 42 // string, int
var v9 = len("gopher")

//var 变量标识符列表 类型 = 表达式列表
var v7, v8 uint = 42, 365

// nil 不能用于类型推导
//var v10 = nil
var v10 []int = nil
var v11 = []int{}
var v12 = map[string]int{}

fmt.Println(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)
// 赋值不属于使用，获取才属于
v3 = 100

// 变量要声明后才能使用
//fmt.Println(v13)
//var v13 = "go"

//var(
//	变量标识符列表 类型
//	变量标识符列表 = 表达式列表
//	变量标识符列表 类型 = 表达式列表
//)
var (
	v1     int
	v2, v3 string
	v4          = 42
	v5, v6      = "go", 42
	v7, v8 uint = 13, 42
)
```

注意事项：

- 类型和表达式列表至少需要一个
- 同类型变量可以集中声明
- 若未提供表达式列表，则变量初始值为类型的零值（默认值）
- 若未提供类型，则由表达式的值推导出每个变量的类型
- 若表达式为未确定类型常量，则使用其默认类型
- 各种数据的值都可以做类型推导
- nil 不能用于类型推导，nil不是具体的某种数据类型的值，表示非法的引用（指针）

### 短变量声明

短变量声明是未提供类型变量声明的快捷语法。`var 变量标识符列表 = 表达式列表`

语法为：

```go
变量标识符列表 := 表达式列表
```

注意使用 `:=` 符号。使用类型推导确定变量具体类型。

变量标识符列表中的变量至少要有一个是新变量。这意味着可以存在之前声明过的变量，相当于重新赋值，要求类型一致。

示例：

```go
// var.go
func VarShortDeclaration() {
	v1, v2 := "go", 42 // string, int
	// 获取v1的地址
	fmt.Printf("&v1: %p\n", &v1)
	v3, v4 := float32(3.14), uint(42) // float32, int
	v5, v1 := []int{1, 2}, "gopher"
	// 再次获取v1的地址，比对前面的结果
	fmt.Printf("&v1: %p\n", &v1)

	fmt.Println(v1, v2, v3, v4, v5)
}

// var_test.go
func TestVarShortDeclaration(t *testing.T) {
	VarShortDeclaration()
}

// go test
typeVarConst> go test -run VarShortDeclaration
&v1: 0xc000026260
&v1: 0xc000026260
gopher 42 3.14 42 [1 2]
PASS
```

注意：短变量声明仅可用在函数或某些语句（例如：for, if, switch）内部。而常规声明也可以用在函数外部。

```go
// 函数外声明变量，需要var常规声明
var outer1 int
var Outer2 string

func VarDeclarationFunc() {
	// 函数内，可以使用常规和短声明
	var inner1 float32
	inner2 := "in func"

	fmt.Println(inner1, inner2)
}
```

## 空白标识符

标识符 `_`称为空白标识符，相当于一个匿名占位符。通常会在声明、赋值时使用到，包匿名导入时：

```go
// 变量声明
var _, exists = m["key"]
_, exists := m["key"] // m map
for _, v := range s { // s slice
  
}

// 常量声明
const (
    v1 = iota // 0
    _
    v3 // 2
    v4 // 3
)

// 变量赋值
v1, _, v3 = func()

// 包匿名导入时
import _ "package"
```

## 类型概述

**类型（数据类型）定义了一组值的集合，以及对于这组值的运算符和特定方法。**

例如：

| 类型   | 值集合      | 运算符 | 特定方法     |
| ------ | ----------- | ------ | ------------ |
| int8   | -128 to 127 | +-x/%  |              |
| string | ""          | +      | len()        |
| []Type | {}          |        | len(), cap() |

Go语言支持预定义类型，复合类型，泛型，自定义类型。

还支持具名类型，类型别名，和匿名类型。

类型支持：

- 数据类型
  - 布尔：bool
  - 数值类型
    - 整数型：int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64
    - 浮点数：float32 float64
    - 复数：complex64 complex128
    - byte：uint8的别名
    - rune：int32的别名
  - 字符串: string
  - 复合类型
    - 数组：Array types
    - 切片：Slice types
    - 结构体：Struct types
    - 映射表：Map types
- 功能类型
  - 指针：Pointer types
  - 接口：Interface types
  - 函数：Function types
  - 通道：Channel types

## 布尔类型 Boolean types

布尔类型用于表示逻辑真假值，布尔类型值只有 `true`和 `false`这两个预声明的常量。

```go
// bool is the set of boolean values, true and false.
type bool bool

// true and false are the two untyped boolean values.
const (
	true  = 0 == 0 // Untyped bool.
	false = 0 != 0 // Untyped bool.
)
```

预声明的布尔类型标识符是 `bool`，是一个定义类型。

> 什么是定义类型， *defined type*？
>
> 一个独立的，与其他类型不同的具名类型。`bool`类型是预定义的定义类型。

零值：

```
false
```

示例：

```go
func TypeBool() {
	var b1 bool // zero value: false
	b2, b3 := true, false

	fmt.Println(b1, b2, b3)
}
```

> 布尔是什么意思？
>
> 布尔代数(Boolean Algebra)，一个数学分支，专门处理"真"和"假"，布尔代数是计算机的基础。
>
> 布尔代数因乔治布尔而得名。乔治布尔，英格兰，1815-1864。

## 整数类型 Integer types

整数类型用于表示整数集合。

预声明的整数类型标识符为：

```go
// 架构无关的 architecture-independent
int8        有符号8位整数集合 (-128 to 127)
int16       有符号16位整数集合 (-32768 to 32767)
int32       有符号32位整数集合 (-2147483648 to 2147483647)
int64       有符号64位整数集合 (-9223372036854775808 to 9223372036854775807)

uint8       无符号8位整数集合 (0 to 255)
uint16      无符号16位整数集合 (0 to 65535)
uint32      无符号32位整数集合 (0 to 4294967295)
uint64      无符号64位整数集合 (0 to 18446744073709551615)

// 特定实现的 implementation-specific， 架构相关的
uint     	无符号整数集合，可能32或64位
int      	有符号整数集合，可能32或64位
uintptr  	一个无符号整数，大到足以存储指针值的未解释位

// 别名
byte        uint8的别名
rune        int32的别名
```

注意：即使int或uint实现的是32位或64位，也与int32和int64，uint32和uint64不是同一个类型。

整型特点：

- 整型都是定义类型
- 未确定类型的整数常量的默认类型为：`int`
- 整型的零值都是：`0`

选择整型依据：

* 位宽够用即可
* 考虑兼容性，和其他代码的兼容性，和其他应用的兼容性
* 常规就是 int，uint，没有任何的选择依据

### 字面量

整型字面量支持多种进制表示法，使用不同的前缀加以区分：42

| 进制                 | 字面量前缀 | 合法数字                     | 字面量   | 值（十进制表示） |
| -------------------- | ---------- | ---------------------------- | -------- | ---------------- |
| 十进制 decimal       | 无         | `0123456789`               | 42       | 42               |
| 二进制 binary        | 0b 或 0B   | `01`                       | 0b101010 | 42               |
| 八进制 octal         | 0o 或 0O   | `01234567`                 | 0o42     | 34               |
| 十六进制 hexadecimal | 0x 或 0X   | `0123456789abcdef(ABCDEF)` | 0x42     | 66               |

示例：

```go
// int.go
func TypeInt() {
	// 默认类型 int
	var idt = 365
	fmt.Printf("%T\n", idt)
	// 零值 0
	var iz int // uint, int8
	fmt.Println(iz)
	// 不同进制
	id, ib, io, ix := 42, 0b101010, 0o42, 0x42
	fmt.Println(id, ib, io, ix) // 42 42 34 66
	fmt.Printf("%T, %T, %T, %T\n", id, ib, io, ix)
}

// int_test.go
func TestTypeInt(t *testing.T) {
	TypeInt()
}

// result
typeVarConst> go test -run TypeInt
int
0
42 42 34 66
int, int, int, int

```

下划线 `_`可以出现在数字之间，用于增加数字的可读性，不会改变字面量的值。

示例：

```go
bigV1 := 12_345_678
bigV2 := 1234_5678
bigV3 := 12_34_56_78
bigV4 := 0x12_34_56_78
fmt.Println(bigV1, bigV2, bigV3, bigV4)
```

## 浮点数类型 Float types

浮点数类型用于表示浮点数集合。

浮点数，floating-point，小数点可以浮动的数，称为浮点数。是与定点数（fixed-point）相对而言的。

何谓小数点浮动？示例十进制小数8.345，可以表示为：

```go
8.345 = .8345 * 10 ^ 1
8.345 = 8.345 * 10 ^ 0
8.345 = 83.45 * 10 ^ -1
8.345 = 834.5 * 10 ^ -2
```

由于使用的指数的不同，小数点的位置也随之改变，这就是小数点浮动的意思。

程序（计算机）中的浮点数，就是采用如上方案存储小数的，因此称为浮点数。不过计算机中是二进制。

通用的公式是：

```go
V = (-1)^S * M * R^E
// S：符号位，取值 0 或 1，决定一个数字的符号，0 表示正，1 表示负
// M：尾数，用小数表示，例如前面所看到的 8.345 * 10^0，8.345 就是尾数
// R：基数，表示十进制数 R 就是 10，表示二进制数 R 就是 2
// E：指数，用整数表示，例如前面看到的 10^-1，-1 即是指数
```

计算机中的浮点数，也是存储以上四个部分。但各个部分占用多少位？就是由 IEEE754 （IEEE二进制浮点数算术标准（ANSI/IEEE Std 754-1985））来确定。标准规范了浮点数一共占用多少位，各个部分占用多少位等，提供了2种浮点数格式：

1. float32，单精度：32 位，符号位 S 占 1 bit，指数 E 占 8 bit，尾数 M 占 23 bit
2. float64，双精度：64 位，符号位 S 占 1 bit，指数 E 占 11 bit，尾数 M 占 52 bit

go语言支持两种浮点数类型，就是：

```go
// type		有效数字	范围
float32		6-7		-3.4*10^38～+3.4*10^38
float64		15~16	-1.7*10^-308~1.7*10^308
```

都是预声明的定义类型。

未确定类型的浮点数常量的默认类型为 `float64`。

浮点数类型的零值：`0`.

> **电气电子工程师学会**（IEEE）的英文全称是the Institute of Electrical and Electronics Engineers，其前身是成立于1884年的美国电气工程师协会 (AIEE)和成立于1912年的无线电工程师协会 (IRE)。 前者主要致力于有线通讯、光学以及动力系统的研究，而后者则是国际无线电领域不断扩大的产物。

### 字面量

支持十进制和十六进制的浮点数字面量。

十进制浮点数字面量由整数部分、小数点、小数部分和指数部分构成。

其中，整数部分或小数部分可以省略，整数部分或指数部分也可以省略。

**指数部分使用e或E连接，位数支持符号，表示10^exp。**

下划线 `_`可以出现在数字之间，用于增加数字的可读性，不会改变字面量的值。

示例：

```go
0.
72.40
072.40       // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
1_5.         // == 15.0
0.15e+0_2    // == 15.0
```

测试：

```go
func TestFloat(t *testing.T) {
	f1, f2, f3, f4 := 3., .25, 6.67428e-11, 1e6
	fmt.Println(f1, f2, f3, f4)
	fmt.Printf("%f, %f, %f, %f\n", f1, f2, f3, f4)
}

// test
typeVarConst> go test -run Float
3 0.25 6.67428e-11 1e+06
3.000000, 0.250000, 0.000000, 1000000.000000
```

十六进制浮点数字面量由0x或0X前缀，整数部分（十六进制），基数点，小数部分（十六进制），和指数部分构成。

其中，整数部分或小数部分可以省略。基数点也可以省略，但此时指数部分就不能省略了，否则会就变成了十六进制整型的字面量了。

**指数部分使用p或P连接，位数支持符号，表示2^exp。**

下划线 `_`可以出现在数字之间，用于增加数字的可读性，不会改变字面量的值。

示例：

```go
0x1p-2       // == 0.25, 1 * (1/2^2) = 1/4
0x2.p10      // == 2048.0, 2.0 * 2^10 = 2048. 
0x1.Fp+0     // == 1.9375, 1.F*2^0 = 1.F = 1*16^0 + 15*16^-1 = 1 + 0.9375 = 1.9375
0X.8p-0      // == 0.5, 0.8 = 8*16^-1 = 1/2 = 0.5
0X_1FFFP-16  // == 0.1249847412109375 , 8191 * 2^-16 = 8191 / 65536 = 0.1249847412109375
0x15e-2      // == 0x15e - 2 (integer subtraction)
```

### 定点数

小数点位置固定的处理方案，就是定点数名字的由来。它既可以表示整数，也可以表示小数。

整数部分、小数部分，按照十进制(也可以是其他进制)转二进制的规则，分别转换存储即可。

示例定点存储3.14：

```go
3.14
// 整数部分 3，转换为二进制
11
// 小数部分 14，转换为二进制
1110
// 之后，根据设计的存储方案分别存储11和1110即可，例如存储方案为：整数2字节，小数2字节，那么最终的存储方案为：
// 整数在前，小数在后
00000000 00000011 00000000 00001110
```

### 精度丢失情况

示例：

```go
func TestFloat2(t *testing.T) {
	a := 1100.1
	b := a * 100   // 110010.0
	fmt.Println(b) // 110009.99999999999
}

// test
> go test -run Float2
110009.99999999999
PASS

```

这不是错误，是计算机处理浮点数的常规现象。

解决方案：

- 使用整型，减小单位，本例中存在1位小数，那么整型a就是11001, b就是1100100，整体数据增加了10倍，通过单位调节，例如元调节为角，米调节为分米。
- 使用定点数。go语言未提供定点数，需要使用第三方实现。

定点数示例：

```go
// 获取包
$ go get -u github.com/shopspring/decimal

// 单测函数
func TestDecimal(t *testing.T) {
	a := decimal.NewFromFloat(1100.1)
	b := a.Mul(decimal.NewFromFloat(100))
	fmt.Println(b)
}

// test
> go test -run Decimal   
110010
```

## 复数类型  Complex Types

形如a+bi（a、b均为实数）的数为复数，其中，a被称为实部，b被称为虚部，i为虚数单位。复数通常用z表示，即z=a+bi，当z的虚部b＝0时，则z为实数；当z的虚部b≠0时，实部a＝0时，常称z为纯虚数。

go支持两种位宽的复数类型：

```go
complex64
complex128
```

未确定类型复数的默认类型为 `complex128`。

复数的零值：`0`

### 字面量

字面量的形式为：z=a+bi，其中i为虚部标识，a, b均可为整数、浮点数。

示例：

```go
x := 1+2i
y := 3.3+4.5i
```

### 内置函数 complex, real, imag

```go
// 构建复数
func complex(r, i FloatType) ComplexType
// 获取实部
func real(c ComplexType) FloatType
// 获取虚部
func imag(c ComplexType) FloatType
```

示例：

```go
func TestComplexFunc(t *testing.T) {
	x := 1 + 2i
	y := complex(3, 4)
	fmt.Println(x, y)

	fmt.Println(real(x), imag(x))
	fmt.Println(real(y), imag(y))
}

> go test -run ComplexFunc
(1+2i) (3+4i)
1 2
3 4

```

## 字节和字符类型 byte，rune types

`byte`是 `uint8`的别名， `rune`是 `int32`的别名。

```go
// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is
// used, by convention, to distinguish byte values from 8-bit unsigned
// integer values.
type byte = uint8

// rune is an alias for int32 and is equivalent to int32 in all ways. It is
// used, by convention, to distinguish character values from integer values.
type rune = int32
```

示例：

```go
var i uint8 = 97
var b byte = 97
var r rune = 97
```

可以使用format，将码值格式化为字符：

```go
// %c, 字符
fmt.Sprintf("%c", 97) // a
```

示例：

```go
func TestByteRune(t *testing.T) {
	var i uint8 = 65
	var b byte = 65
	var r rune = 65
	fmt.Println(i, b, r)
	fmt.Printf("%c, %c, %c\n", i, b, r)
}

> go test -run ByteRune   
65 65 65
A, A, A   
PASS 
```

byte和rune类型用于在逻辑上，处理单字节和多字节字符.

- byte代表基本拉丁(ASCII码)和补充拉丁字母的码值，[0-255]
- rune代表Unicode码值,[0, 0xffffffff]

通常使用字符直接为byte或rune类型赋值。

### rune类型的字面量

rune类型有字面量语法，而byte类型没有特定的字面量语法。

**单引号**包裹的一个或多个字符，就是rune类型的字面量，注意一对单引号只能定义一个rune类型字符。例如：`'x'` 或 `'\n'`。实际的值是字符的unicode码值(utf8码值）。

字面量说明：

- 直接支持任意字符
- 换行和单引号不能直接出现在字面量内，需要转义
- 支持unicode码值表示字符，码值参考https://symbl.cc/cn/unicode-table/
  - \OOO，3个八进制数，范围\000-\377。
  - \xHH，2个十六进制数
  - \uHHHH，4个十六进制数
  - \UHHHHHHHH，8个十六进制数
- 支持转义字符

rune字面量支持的转义字符：

```go
\a   U+0007 alert or bell
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed or newline
\r   U+000D carriage return
\t   U+0009 horizontal tab
\v   U+000B vertical tab
\\   U+005C backslash
\'   U+0027 single quote  (仅在单引号定义rune字符类型时可用)

// 忽略\"
\"   U+0022 double quote  (仅在双引号定义string字符串类型时可用)
```

示例：

```go
func TestRuneLiteral(t *testing.T) {
	// 任意字符
	var r1, r2, r3 = 'A', 'Ⅵ', '丕'
	// 码值
	var r4, r5, r6, r7 = '\101', '\x41', '\u4E15', '\U00101234'
	// 转义字符
	var r8, r9, r10 = '\n', '\'', '\\'
	fmt.Println(r1, r2, r3, r4, r5, r6, r7, r8, r9, r10)
	fmt.Printf("%c,%c,%c,%c,%c,%c,%c,%c,%c,%c\n", r1, r2, r3, r4, r5, r6, r7, r8, r9, r10)
}

> go test -run RuneLiteral
65 8549 19989 65 65 19989 1053236 10 39 92
A,Ⅵ,丕,A,A,丕,􁈴,
,',\
PASS

```

### Byte类型的赋值

byte类型没有字面量语法。但如果码值为[0, 255]，那么也可以将rune字面量赋值给byte类型变量，因为其实都是整数。

因为Go语言源码是UTF8字符集，UTF8是变长字符集，一些字符占用1个字节，因此可以使用这部分的字符直接为byte类型赋值。这部分内容包括基本拉丁(ASCII码)和补充拉丁字母。

示例：

```go
func TestByteAssign(t *testing.T) {
	var b1 byte = 97
	var b2 byte = 'a'
	b3 := byte(97)
	b4 := byte('a')
	var b5, b6 byte = 'Ò', 'Ø'
	fmt.Println(b1, b2, b3, b4, b5, b6)
	fmt.Printf("%c, %c, %c, %c, %c, %c\n", b1, b2, b3, b4, b5, b6)
}

> go test -run ByteAssign 
97 97 97 97 210 216
a, a, a, a, Ò, Ø  
PASS
```

## 字符串类型 String types

字符串类型用于表示字符串集合。

字符串为字节序列，可以为空。

预声明的类型标识符为 `string`，也是预声明的定义类型。

字符串类型的零值为：`""`， 空字符串。

### 字面量

支持两种字面量：

- 原生字符串字面量， raw string，反引号语法
- 解释字符串字面量，interpreted string, 双引号语法

#### 原生字符串字面量

使用**反引号**包裹。

反引号内，可以出现除了反引号本身之外的任意字符。字符串的值就是反引号的内容，不会对转义字符和unicode字符编码做解释。

示例：

```go
func TestStringRaw(t *testing.T) {
	s1 := `raw \n
\n string\100\x25`
	fmt.Println(s1)
}

> go test -run StringRaw
raw \n   
\n string\100\x25
PASS
```

#### 解释字符串字面量

使用**双引号**包裹。

双引号内，除了换行和双引号外任何字符可以出现，双引号、换行需要使用转义字符表示。

类似rune类型，解释字符串会解释转义字符，和字符码值。

转义字符：单引号不需要转义。

```go
\a   U+0007 alert or bell
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed or newline
\r   U+000D carriage return
\t   U+0009 horizontal tab
\v   U+000B vertical tab
\\   U+005C backslash
\"   U+0022 double quote  (仅在双引号定义string字符串类型时可用)

// 忽略
\'   U+0027 single quote  (仅在单引号定义rune字符类型时可用)
```

字符码值：

```go
\OOO，3个八进制数，范围\000-\377。
\xHH，2个十六进制数
\uHHHH，4个十六进制数
\UHHHHHHHH，8个十六进制数
```

示例：

```go
func TestStringInterp(t *testing.T) {
	s1 := "raw \n\n string\100\x25"
	fmt.Println(s1)
}

> go test -run StringInterp
raw

 string@%
PASS
```

### 字符串长度

字符串中的字节数称为字符串的长度，长度不会为负数。内置函数 `len`可以获取字符串的长度，`len(s)`如果s为字符串常量，那么 `len(s)`也是常量，编译时即可确定。

示例：

```go
func TestStrLen(t *testing.T) {
	s1 := "raw \n\n string\100\x25"
	fmt.Println(s1, len(s1))

	s2 := "Go语言编程"
	fmt.Println(s2, len(s2))
}

> go test -run StrLen
raw 

 string@% 15
Go语言编程 14
```

### 字节索引访问

字符串中的字节可以通过索引访问（只能访问不能修改），索引语法为：`s[i]`，索引范围：`[0, len-1]`。

字符串是不可改变的，一旦创建，不能修改字符串内容。

示例：

```go
func TestStrIndices(t *testing.T) {
	s1 := "Go语言编程"
	fmt.Println(s1)
	fmt.Println(s1[0])        // byte
	fmt.Println(s1[1])        // byte
	fmt.Println(s1[2])        // byte
	fmt.Printf("%c\n", s1[2]) // byte
}

> go test -run StrIndices
Go语言编程
71
111
232
è
PASS
```

## 数组类型 Array types

数组是固定数量元素的序列，元素的类型需要一致。

| 元素 | 元素 | 元素 |
| ---- | ---- | ---- |

元素类型和数组类型，例如：

```
[3]int
// 数组类型：长度为3的整型数组
// 元素类型：int

[4]int
// 数组类型：长度为4的整型数组

[4]int 与 [3]int 不是同一个类型
```

数组没有预声明的类型标识符。

### 类型字面量

数组类型需要构造出来。构造数组类型时，需要提供长度和元素类型，数组的类型字面量为：

```go
[ArrayLength]ElementType
// ArrayLength 为整型常量
// ElementType 为任意数据类型，不能为自身
```

数组类型都是一维的。若元素类型为数组类型，则可以构造多维的数组。

```go
[ArrayLength1]ElementType1 
ElementType1 = [ArrayLength2]ElementType2
[ArrayLength1][ArrayLength2]ElementType2
```

示例：

```go
// 长度为3，元素类型为int的数组类型
[3]int

// 长度为4，元素类型为[5]float32的数组类型
// 长度为4，元素类型为(长度为5，元素类型为float32的数组类型)的数组类型
[4][5]float32
```

### 声明数组类型

type 关键字用于声明类型，可以将类型和类型标识符绑定。

```go
type 标识符 数组类型字面量
```

声明标识符的数组类型，可以直接使用。

示例：

```go
// 声明类型
type arrInt3 [3]int
// 声明类型
type arrInt4 [4][5]float32
```

### 值的构造字面量

构造数组类型的值，需要使用如下形式：

```go
ArrayType {ElementList}
ElmentList = IndexedElement[, IndexedElement] 
IndexedElement = [Index:] Element

// 自动确定数组长度
[...]ElementType
```

说明如下：

- 类型后大括号，表示该类型的值
- 大括号中为支持索引的元素列表
- 元素索引和值使用分号分隔，索引为整数，值为元素类型的值
- 元素可以省略，那对应的元素为类型零值
- 元素的索引可以省略，那么索引为前一个元素的索引+1
- 第一个元素索引为0
- `...`表示数组长度为最大元素索引+1，可以通过元素列表自动确定数组长度

示例：

```go
func TestArrayType(t *testing.T) {
	// 长度为3，元素类型为int的数组类型
	// 声明类型
	type arrInt3 [3]int

	// 长度为4，元素类型为[5]float32的数组类型
	// 长度为4，元素类型为(长度为5，元素类型为float32的数组类型)的数组类型
	// 声明类型
	type arrInt4 [4][5]float32

	// 全部的元素为元素类型零值
	a1 := [3]int{}
	a2 := arrInt3{0, 0, 0} // [3]int{0, 0, 0}
	// 完整的索引:值的表示
	a3 := [3]int{0: 10, 1: 20, 2: 30}
	// 省略部分元素，省略的元素，为元素类型零值
	var a4 arrInt3 = [3]int{0: 10, 2: 30} // 10, 0, 30
	// 元素索引也可以省略，索引为前一个元素的索引+1
	// 第一个元素索引为0
	a5 := [3]int{1: 20, 30}           // 0:0, 1:20, 1+1:30
	a6 := [7]int{1: 5, 3: 50, 60, 70} // 0:0, 1:5, 2:0, 3:50, 3+1:60, 3+1+1:70, 6:0

	// ... 自动确定数组长度，最大元素索引+1
	a7 := [...]int{1, 5, 8, 5: 90, 5, 9: 12, 111} // 10 + 1 [11]int
	fmt.Println(a1, a2, a3, a4, a5, a6, a7)

	// 多维数组的字面量
	a8 := [3][2]float64{
		0: [2]float64{
			0: 1.2,
			1: 3.4,
		},
		1: [2]float64{
			0: 5.6,
			1: 7.8,
		},
		2: [2]float64{
			0: 9.0,
			1: 0.1,
		},
	}

	// 上面的结构可以省略语法
	a8 := [3][2]float64{
		0: {0: 1.2, 1: 3.4,},
		1: {0: 5.6, 1: 7.8,},
		2: {0: 9.0, 1: 0.1,},
	}
}

> go test -run ArrayType 
[0 0 0] [0 0 0] [10 20 30] [10 0 30] [0 20 30] [0 5 0 50 60 70 0] [1 5 8 0 0 90 5 0 0 12 111]
[[1.2 3.4] [5.6 7.8] [9 0.1]] [[1.2 3.4] [5.6 7.8] [9 0.1]]
PASS
```

### 数组的长度

元素的数量称为数组的长度，长度是数组类型的一部分。长度不能为负数。内建函数 `len`用于获取数组长度。

示例：

```go
func TestArrayLen(t *testing.T) {
	a1 := [3]int{}
	a2 := [4][2]int{}
	fmt.Println(len(a1), len(a2))
}

> go test -run ArrayLen
3 4

```

### 元素的定位

元素可通过索引定位，索引范围：`[0,len-1]`。

示例：

```go
func TestArrayIndices(t *testing.T) {
	a1 := [7]int{1: 5, 3: 50, 60, 70}
	fmt.Println(a1[2], a1[4])

	a2 := [3][2]float64{
		0: {0: 1.2, 1: 3.4},
		1: {0: 5.6, 1: 7.8},
		2: {0: 9.0, 1: 0.1},
	}
	fmt.Println(a2[1])
	fmt.Println(a2[1][1])
	// 先访问0索引，得到数组类型的值，再访问
	fmt.Println((a2[1])[1])

	// 元素支持取地址
	fmt.Println(&a1, &a1[1], &(a1[1]))
}

> go test -run ArrayIndices
0 60
[5.6 7.8]
7.8
7.8
&[0 5 0 50 60 70 0] 0xc00013c0c8 0xc00013c0c8
```

数组元素可以单独取地址。

```go
&ArrayVar[i]
```

## 切片类型 Slice types

切片是操作**底层数组一段连续空间**的描述符。

切片类型表示基于某个底层数组的全部切片集合。指的是一个底层数组上可以存在多个切片，这些切片就是该切片类型的值。

如图：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/13080/1712481344010/5b1eba58d29548548fcbcaea5d614a85.png)

切片没有预声明的类型标识符，需要通过类型字面量来构建。

slice类型的零值为：`nil`。也称作：未初始化的切片值是nil。

元素可通过索引定位，索引范围：`[0,len-1]`。

### 类型字面量

```go
SliceType = []ElementType
```

### 值字面量

```go
SliceType {IndexedElementList}
IndexedElementList = IndexedElement[, IndexedElement]
```

规则与数组类似：

- 类型后大括号，表示该类型的值
- 大括号中为支持索引的元素列表
- 元素索引和值使用分号分隔，索引为整数，值为元素类型的值
- 元素可以省略，那对应的元素为类型零值
- 元素的索引可以省略，那么索引为前一个元素的索引+1
- 第一个元素索引为0

示例：

```go
func TestSlice(t *testing.T) {
	// s1 为 nil
	var s1 []int
	// s2 为空切片
	s2 := []int{}
	// s3 不是空切片
	s3 := []int{23, 4: 45, 66, 9: 32, 666} // len == 11
	fmt.Println(s1, s1 == nil)
	fmt.Println(s2, s2 == nil)
	fmt.Println(s3)
}

> go test -run Slice
[] true
[] false
[23 0 0 0 45 66 0 0 0 32 666]
PASS
```

切片一旦显示初始化，就会与用于存储其元素的底层数组关联。

该方案会构建一个与底层数组长度一致的切片。（将整个数组做成一个切片）

### 基于数组构（切片）建切片

切片表达式可以基于数组或切片构建切片：

```go
a[low : high] // 开始于索引low, 结束于索引high，不包括high
a[low:]  // a[low : len(a)]
a[:high]  // a[0 : 3]
a[:]   // a[0 : len(a)]
```

此时，切片的长为 `high-low`。

相同底层数组的不同切片会共享数据。（相对于数组来说，数组间不会共享数据）

示例：

```go
func TestSliceArray(t *testing.T) {
	arr := [7]string{"g", "o", "p", "h", "e", "r", "s"}
	// 切片表达式
	s1, s2, s3, s4, s5 := arr[:3], arr[1:3], arr[2:6], arr[4:], arr[:]
	fmt.Println(s1, s2, s3, s4, s5)

	arr[2] = "P"
	fmt.Println(s1, s2, s3, s4, s5)

	s3[0] = "Q"
	fmt.Println(s1, s2, s3, s4, s5)
}

> go test -run SliceArray
[g o p] [o p] [p h e r] [e r s] [g o p h e r s]
[g o P] [o P] [P h e r] [e r s] [g o P h e r s]
[g o Q] [o Q] [Q h e r] [e r s] [g o Q h e r s]
PASS
```

### 长度和容量

切片的长度指的是切片的元素个数，通过内建函数 `len`获取。程序执行期间，切片的长度会变化。

**容量指的是底层数组从切片开始扩展到数组末尾的元素个数。通过内建函数 `cap`来获取。**

示例：

```go
func TestSliceLenCap(t *testing.T) {
	arr := [7]string{"g", "o", "p", "h", "e", "r", "s"}
	// 切片表达式
	s1, s2, s3, s4, s5 := arr[:3], arr[1:3], arr[2:6], arr[4:], arr[:]
	fmt.Println(len(s1), cap(s1))
	fmt.Println(len(s2), cap(s2))
	fmt.Println(len(s3), cap(s3))
	fmt.Println(len(s4), cap(s4))
	fmt.Println(len(s5), cap(s5))
}

> go test -run SliceLenCap
3 7
2 6
4 5
3 3
7 7
PASS
```

### make构建

内置函数make，常用来构建切片：

```go
make([]T, length, capacity)
// 类型，长度，容量
```

示例：

```go

```

当确定长度或容量的时候，推荐使用make构建切片。

切片表达式，可以设置容量：

```go
a[low : high : max]
```

切片的长度为:  **`high-low`

切片的容量为: **`max - low`

示例：

```

```
