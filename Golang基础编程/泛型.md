# 泛型 Generic Type

泛型是一种在编程中实现**代码复用**和类型安全的重要技术。它包括两种主要形式：**泛型函数**和**泛型类型**。

- 泛型函数：泛型函数是指使用了**泛型参数**的函数。它允许**函数在定义时不指定具体的类型**，而是在**调用时由用户指定具体类型或通过编译器推导类型。**

- 泛型类型：泛型类型是指使用了**泛型参数**的类型（如结构体或接口）。它允许**定义一种通用的类型，在实例化时根据需求指定实际类型。**

泛型主要包括以下几个部分：**泛型函数**、**泛型类型**、**类型参数**、**类型约束** 和 **预定义泛型特性**。

- **类型参数**用于指定函数或类型中可以使用的类型，通常是泛型的核心部分。
- **类型约束**用来限制类型参数的取值范围，通常通过接口实现。
- **预定义泛型特性**如 `any`、`comparable` 和 `constraints.Ordered`。

## 类型参数 Type Parameter

Go中通过类型参数来支持泛型的。类型参数需要配合类型和函数的定义来一起使用。

相关概念：

- 类型形参，Type parameter，定义时的类型参数
- 类型约束，Type Constraint，定义类型参数时对参数做的类型上的约束。**类型约束其实就是接口interface。**
- 实例化，Instantiations，**使用类型实参替换类型形参而得到具体类型的过程称为实例化。**
- 类型实参，Type Argument，**实例化时传递的实际参数**

使用场景：

- 泛型类型，generic type，类型定义中带有类型参数的，称为泛型类型。
- 泛型接收器，接收器类型为泛型类型的，称为泛型接收器。
- 泛型函数，generic function，函数定义中带有类型参数的，称为泛型函数。
- 泛型接口，接口定义中带有类型参数的，称为泛型接口。

## 泛型类型 Generic Type

**类型定义中带有类型参数的，称为泛型类型。**泛型类型定义示例：注意前面要有type关键字，定义后面的[]T等是基础类型

```go
// 支持特定元素类型的切片
type mySlice[T int | string] []T // mySlice[T]

// 支持特定Key，Value类型的map
type myMap[K int | string, V float32 | float64] map[K]V // myMap[K, V]

// 支持特定字段类型的结构体
type myList[T int | float64] struct { // myList[T]
    data []T
    l    int
    max, min, avg T
}
```

泛型类型实例化示例：

```go
intSlice := mySlice[int]{}
stringSlice := mySlice[string]{}
fmt.Printf("%T, %T\n", intSlice, stringSlice)

intKeyMap := myMap[int, float64]{}
stringKeyMap := myMap[string, float32]{}
fmt.Printf("%T, %T\n", intKeyMap, stringKeyMap)
```

结果：

```shell
>go test -run=TP
ref.mySlice[int], ref.mySlice[string]
ref.myMap[int,float64], ref.myMap[string,float32]
PASS
```

以 myMap为例，说明相关概念：

```go
// 泛型类型是myMap[K,V]
// 类型参数（形参）列表：[K int | string, V float32 | float64]
// K的类型约束：int | string，V的类型约束：float32 | float64
// 基础类型：map[K]V
type myMap[K int | string, V float32 | float64] map[K]V

// 实例化
// 类型参数实参：string, float32
stringKeyMap := myMap[string, float32]{
"go":    98,
"mysql": 88.5,
}
```

### 类型约束支持指定基础类型

类型约束中主要使用 | 表示或。使用**~T表示，以T为基础类型的类型都支持。**

示例：

```go
type intS[T ~int] []T
type myInt int
type yourInt myInt
// 以下三个都是支持的
var a intS[int]
var b intS[myInt]
var c intS[yourInt]

// int32不支持，因为int32未实现~int（~int中缺少int32）
var d intS[int32]
```

### 基于泛型定义类型

**泛型类型可以作为其他泛型类型的基础类型**来定义，示例：

```go
// 泛型基础类型
type Slice[T int | string | float32 | float64] []T

// 用在类型定义时
type FloatSlice[T float32 | float64] Slice[T]
// 用在结构体字段中
type myStruct[T float32 | float64] struct {
    F1 Slice[T]
}
// 用在map中
type myMap[T float32 | float64] map[string]Slice[T]
```

### 泛型类型语法注意事项（看下视频）

1. **类型参数不能直接作为类型声明右侧（RHS）** 使用

在 Go 中，**类型参数只是一个占位符，并不是真正的类型**。编译器在编译泛型代码时，并不知道 `T` 的具体类型，因此无法直接用类型参数来实例化、声明或操作。

```go
func CreateInstance[T any]() T {
    return T{} // 错误：不能直接实例化类型参数
}
```

2. 匿名结构体不支持泛型类型参数

```go
func CreateStruct[T any](value T) {
    s := struct {
        field T
    }{
        field: value,
    }
    fmt.Println(s.field)
}
// 编译时会报错：cannot use generic type T in an anonymous struct
```

**原因分析：**

- **泛型的类型参数需要具体绑定：**

  - **泛型类型参数 `T` 在编译时替换为具体类型。**
  - **匿名结构体是直接定义和使用的**，无法提前确定其字段类型的绑定。

- **匿名结构体的局限性**：匿名结构体是内联定义的，不支持泛型特性中的**类型推导和约束处理**。

  

3. 类型约束可能会导致语法歧义

   例如：

   ```go
   func Example[T int | string](arg T) { ... }
   // 调用
   Example[int | string](value)
   ```

   理解 1：`int | string` 是类型约束，`T` 可以是 `int` 或 `string`。

   ```go
   func Example[T int | string](arg T) { ... }
   Example[int | string](value) // 泛型调用
   ```

   理解 2：`int | string` 是函数调用的实际参数，相当于`T (int | string)`，| 是运算符“或”

   ```go
   func Example(arg any) { ... }
   Example(1 | 2) // 函数调用，参数是表达式
   ```

   **解决方案：**

   - 在类型参数约束后**加上逗号**，例如：`type T[P *int | *string,] []P`

     在类型参数约束后加上逗号（`,`），可以明确告诉编译器，这个表达式是一个**类型参数约束列表**，而不是函数调用参数列表。

   - 使用 `interface{}` 包裹类型约束，例如：`type T[P interface{ *int | *string }] []P`，避免被解析为其他表达式。

示例：

```go
// 1、不能在类型声明中将类型参数用作RHS
type mySlice[T int | string] T

// 2、匿名结构体不支持泛型类型参数
[T int | string]struct{ //struct[T int|string]{
    name T
}{
    name: "Go"
}

// 3、语法歧义
type T[P *int] []P // P * int 乘法
type T[P (int)] []P // P(int) 函数调用
type T[P *int|string] []P // P*int|string， P乘以int位或string
// 无效的数组绑定 'T*int |*string' 必须是一个常量表达式（编译器将 T*int 误解为乘法表达式）
type pointSlice[T *int|*string] []T
// 解决方案
type pointSlice[T *int | *string,] []T
type pointSlice[T interface{ *int | *string }] []T
```



## 泛型接收器

接收器类型为泛型类型的接收器，称为泛型接收器。也就是泛型类型的方法。

带有泛型接收器的方法，可以在**参数、返回值位置**使用类型参数，来提高方法的通用性。

并发的slice操作示例代码：

```go
// 一：定义泛型类型
type myList[T int | float64] struct {
    data     []T
    max, min T
    m        sync.Mutex
}

// 二、定义泛型类型的方法集
// 1.添加元素，更新最大值最小值
// 泛型接收器, 泛型类型参数类型
func (l *myList[T]) Add(ele T) *myList[T] {
    // 加锁并发安全考虑
    l.m.Lock()
    defer l.m.Unlock()

    // 更新 data
    l.data = append(l.data, ele)

    // 统计 min max
    if len(l.data) == 1 {
        l.max = ele
        l.min = ele
    }

    if ele > l.max {
        l.max = ele
    }

    if ele < l.min {
        l.min = ele
    }

    return l
}

// 2.获取元素
func (l myList[T]) All() []T {
    return l.data
}

func (l myList[T]) Max() T {
    return l.max
}

func (l myList[T]) Min() T {
    return l.min
}

func GenericReceiver() {
    l := myList[int]{}
    // 添加元素
    l.Add(1).Add(3).Add(10)
    // 获取元素
    fmt.Println(l.All())
    fmt.Println(l.Max(), l.Min())
}
```

练习：

定义队列，支持**多种类型**的push，pop操作。使用泛型实现。

示例代码：

```go
type Queue[T int | string] struct {
    data []T
}

func (q *Queue[T]) Put(v ...T) *Queue[T] {
    q.data = append(q.data, v...)
    return q
}

func (q *Queue[T]) Pop() (T, bool) {
    var v T
    if len(q.data) == 0 {
        return v, true
    }

    v = q.data[0]
    q.data = q.data[1:]
    return v, len(q.data) == 0
}

func (q Queue[T]) Size() int {
    return len(q.data)
}
```

## 泛型函数

带有类型参数的函数，称为泛型函数。**可以让一段函数代码，具备同时处理多种相似类型数据的能力。**

示例：

```go
func Sum[T int | string](ele ...T) T {
    var s T
    for _, v := range ele {
        s += v
    }
    return s
}

func GenericFunc() {
    fmt.Println(Sum[int](1, 2, 3))
    fmt.Println(Sum[string]("ma", "shi", "bing"))
}
```

注意：**没有匿名泛型函数的说法**，不能使用类型参数，来实现匿名泛型函数。但是，可以在匿名函数内，使用所处函数的类型参数：

示例：

```go
func Sum[T int | string](ele ...T) T {
    var s T
    for _, v := range ele {
        s += v
    }
    // 匿名函数可以使用所处的函数中定义的类型参数
    func(n T) {}(s)
    return s
}
```

## 泛型函数的类型推断，Type Inference

1. 缺少的类型参数的泛型函数可以**通过参数判定类型**，方便了泛型函数的调用：

```go
func GuessType[T int | string](ele ...T) T {
	var s T
	for _, v := range ele {
		s += v
	}
	return s
}

func Inference() {
	fmt.Println(GuessType(1, 2, 3)) // 自动推断 T 为 int
	fmt.Println(GuessType("ma", "shi", "bing")) // 自动推断 T 为 string
}
```

测试：

```powershell
> go test -run=Inference -v
=== RUN   TestInference
6
mashibing
--- PASS: TestInference (0.00s)
PASS
ok      github.com/han-joker/goExample/generalType      0.038s
```

2. **类型推断在使用时，支持省略全部或部分类型参数**，例如：

```go
func GuessType2[K int | string, V float64 | string](p1 K, p2 V) {}
// 全部指定
GuessType2[int, string](42, "Ma")
// 指定前面部分
GuessType2[int](42, "Ma")
// 全部省略
GuessType2(42, "Ma")
```

注意：不允许中间参数跳过，指定后边部分，例如 `GuessType2[string](42, "Ma")`是错误的。

3. 推断的类型必须要合理，例如下面的K和V的类型要保持一致，例如：

```go
// 函数定义
func GuessType3[K int | string, V []K](p1 K, p2 V) {}

// 合理
GuessType3(42, []int{})
// 不合理，因为K和V的类型冲突了
GuessType3(42, []string{})
```

## 泛型接口

使用了类型参数的接口，称为泛型接口。示例：

```go
type Data[T int | string] interface {
	Process(T) (T, error)
	Save(data T) error
}
```

以上泛型接口，在使用时，同样需要传递具体实参类型，才有意义，示例：

```go
func DataOperate(d Data[string]) {}
// 
Data[string]相当于↓

type Data interface {
	Process(string) (string, error)
	Save(data string) error
}
```

**类型在实现接口时，必须要实现 Data[string] 才可以**，例如：

```go
type JsonData struct{}

func (JsonData) Process(string) (string, error) {
	return "", nil
}

func (JsonData) Save(string) error {
	return nil
}

type NumberData struct{}

func (NumberData) Process(int) (int, error) {
	return 0, nil
}

func (NumberData) Save(int) error {
	return nil
}

func GenerateInterface() {
	// 参数类型正确
	DataOperate(JsonData{})
	// 参数类型错误
	DataOperate(NumberData{})
}
```

泛型接口的主要作用是通过引入类型参数，**为多种类型提供统一的抽象和灵活的实现。**

# 接口

## 方法集更新为类型集

1.18前，接口的定义为：

> An interface type specifies a **method set** called its interface

1.18后，接口的定义为：

> An interface type defines a ***type set\***

大家注意，由 method set 变化为 type set。

示例：

- 方法集合

```go
type ReadWriter interface {
	Read(p []byte) (n int, err error)
	Write(p []byte) (n int, err error)
}
```

- 类型集合

```go
type Float interface { 
    ~float32 | ~float64 
}
```

这个接口的作用是**约束类型参数**，只允许类型参数是**底层类型为 `float32` 或 `float64` 的类型**。

- 组合了类型约束和接口方法的泛型接口

```go
// 混合
type FloatReadWriter interface {
	~float32 | ~float64
	Read(p []byte) (n int, err error)
	Write(p []byte) (n int, err error)
}
```

这个接口适用于**底层类型为 `float32` 或 `float64` 的类型**，并要求实现 Read 和 Write 方法。实现接口的示例代码如下：

```go
// 定义 FloatReadWriter 接口
type FloatReadWriter interface {
	~float32 | ~float64                       // 类型约束
	Read(p []byte) (n int, err error)         // 行为约束：读取方法
	Write(p []byte) (n int, err error)        // 行为约束：写入方法
}

// 定义一个实现 FloatReadWriter 的自定义类型
// MyFloat 是一个基于 float64 的自定义类型，因此它满足 ~float64 的约束。
type MyFloat float64 

// 实现 Read 方法
func (f *MyFloat) Read(p []byte) (int, error) {
	if len(p) == 0 {
		return 0, errors.New("buffer is empty")
	}
	// 将当前值转换为字符串形式并复制到 p 中
	data := fmt.Sprintf("%f", *f)
	n := copy(p, []byte(data))
	return n, nil
}

// 实现 Write 方法
func (f *MyFloat) Write(p []byte) (int, error) {
	// 尝试将输入字节解析为浮点数，并更新自身的值
	var value float64
	_, err := fmt.Sscanf(string(p), "%f", &value)
	if err != nil {
		return 0, err
	}
	*f = MyFloat(value) // 更新值
	return len(p), nil
}

// 使用 FloatReadWriter 的示例函数
func UseFloatReadWriter[T FloatReadWriter](frw T) {
	// 写入值
	input := []byte("123.456")
	_, err := frw.Write(input)
	if err != nil {
		fmt.Println("Write error:", err)
		return
	}
	fmt.Println("Write success!")

	// 读取值
	var buffer [128]byte
	n, err := frw.Read(buffer[:])
	if err != nil {
		fmt.Println("Read error:", err)
		return
	}
	fmt.Println("Read success:", string(buffer[:n]))
}

func main() {
	// 定义一个 MyFloat 实例
	var myValue MyFloat = 0

	// 调用泛型函数处理 MyFloat 实例
	UseFloatReadWriter(&myValue)
}

```

## 接口中元素的逻辑关系

接口中的元素，存在并集和交集的关系

- 并集：| 表示并集，实现其中一个元素即可
- 交集：行之间表示交集，全部行都要实现

因此以上3种接口语法分别表示：

```go
// 方法集合
// 要同时实现 Read 和 Write
type ReadWriter interface {
	Read(p []byte) (n int, err error)
	Write(p []byte) (n int, err error)
}

// 类型集合
// 要实现 float32 或 float64 ， ~表示以T为基础类型
type Float interface {
	~float32 | ~float64
}

// 混合
// 要实现 float32 或 float64，同时实现Read和Write
type FloatReadWriter interface {
	~float32 | ~float64
	Read(p []byte) (n int, err error)
	Write(p []byte) (n int, err error)
}
```

## 空集

行之间为交集关系，那就意味着可能出现空集，例如：

```go
type Empty interface {
    int
    string 
}
```

这种空集接口编译可以通过，但**使用上没实际意义**。

注意，空集接口与空接口interface{}是不同的，两个极端：

- **空集接口，不会有任何类型实现**
- **空接口interface{}，全部类型都实现了这个接口**

## 使用接口

**仅包含方法集的接口，称为基本接口**，与之前接口使用方式保持一致。

**包含了类型集的接口，称为一般接口**，只能用在泛型的类型约束中。

## 类型约束本质是接口

**类型参数的类型约束，其实就是接口**。因此当出现语义冲突时可以使用interface标识符：

```go
// 语法歧义
type T[P *int] []P // P * int 乘法
type T[P (int)] []P // P(int) 函数调用
type T[P *int|string] []P // P*int|string， P乘以int位或string
// Invalid array bound 'T*int | *string', must be a constant expression
type pointSlice[T *int|*string] []T
// 解决方案
type pointSlice[T *int | *string,] []T
type pointSlice[T interface{ *int | *string }] []T
```

## 预定义的接口的使用

### interface{}和any

interface{} 表示任何类型的集合，可以使用关键字 any表示。

any 的定义：

```go
// any is an alias for interface{} and is equivalent to interface{} in all ways.
type any = interface{}
```

如果有需要，使用命令`gofmt -w -r 'interface{} -> any' ./...` 可以将 interface{} 全部更新为 any。

### comparable（可比较）

comparable是一个预定义的泛型接口，用于表示**可以进行比较的类型**。具体来说，所有支持 `==` 和 `!=` 运算符的类型都实现了 `comparable` 接口。

**comparable 接口只能用作类型参数的约束，不能用作变量的类型。**

```go
type comparable interface{ 
    comparable 
}
```

从语法上看，`comparable` 相当于一个空接口，但其真正的意义在于**它的使用隐式地要求类型参数支持比较操作**。包括：

**基本类型**：

- 整型（如 `int`, `int32`）
- 浮点型（如 `float32`, `float64`）
- 字符串 (`string`)
- 布尔值 (`bool`)
- 指针类型（如 `*int`）
- 通道类型（元素类型可比较的，如 `chan int`）

**复合类型**：

- 数组（长度相同且元素类型满足 `comparable`）
- 结构体（所有字段的类型都满足 `comparable`）

**注意：** 切片（`slice`）、映射（`map`）、和函数（`func`）不支持 `==` 和 `!=`，因此它们不满足 `comparable` 接口。

典型的，我们要求map类型的key就是可比较的（**这句话与上面内容无关**）

```go
type myMap[K comparable, V any] map[K]V
```

若定义成：

```go
type myMap[K, V any] map[K]V
```

就是错误的。

**注意：可比较是比较是否相等。不保证比较大小**。也就是comparable 不保证支持 \>,<,<=,>= 运算。

**用法示例：比较两个值是否相等**

```go
// 泛型函数：判断两个值是否相等
func IsEqual[T comparable](a, b T) bool {
    return a == b
}

func main() {
    fmt.Println(IsEqual(42, 42))       // 输出: true
    fmt.Println(IsEqual("hello", "hi")) // 输出: false
    fmt.Println(IsEqual(true, false))   // 输出: false
}
```

### ordered（可排序）

`ordered` 限制的是支持排序运算（`<`, `<=`, `>`, `>=`）的类型。典型使用如下：

```go
type Ordered interface {
    Integer | Float | ~string
}

type Integer interface {
    Signed | Unsigned
}

type Signed interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64
}

type Unsigned interface {
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr
}

type Float interface {
    ~float32 | ~float64
}
```

注意：ordered 不是 Go 内置接口，如果需要使用，必须手动定义。

示例：排序函数

```go
// 定义 ordered 接口
type ordered interface {
    ~int | ~float64 | ~string
}

// 泛型排序函数
func Min[T ordered](a, b T) T {
    if a < b {
        return a
    }
    return b
}

func main() {
    fmt.Println(Min(10, 20))       // 输出: 10
    fmt.Println(Min(5.5, 2.3))    // 输出: 2.3
    fmt.Println(Min("cat", "dog")) // 输出: cat
}
```



### Number 数值

```go
type Integer interface {
	Signed | Unsigned
}
type Signed interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64
}
type Unsigned interface {
	~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr
}
type Float interface {
	~float32 | ~float64
}
type Number interface {
	Float | Integer
}
```

示例：计算两个整数的和

```go
// 定义 Integer 接口
type Integer interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 |
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr
}

// 泛型函数：计算两个整数的和
func Add[T Integer](a, b T) T {
    return a + b
}

func main() {
    fmt.Println(Add(10, 20))       // 输出: 30
    fmt.Println(Add(int8(5), int8(3))) // 输出: 8
}
```

