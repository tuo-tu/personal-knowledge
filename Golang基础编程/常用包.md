# 标准包 embed

go  1.16

通过引入embed包，在代码中使用//go:embed指令，可以**将静态文件编译进Go的二进制执行文件中**。该特性的功能：

- 保证程序的完整性，将程序需要依赖的全部资源打包到一个二进制程序中
- 易于部署，程序需要的资源全部在一个二进制文件中，各种部署都变得简单
- 常用的资源访问，在编译时搞定，省去运行时IO的开销，提升效率

场景的案例：

- 静态web服务器
- 后端模板载入
- 常用静态资源响应

## 导入包

```go
import _ "embed"
import "embed"
```

## 嵌入指令

```go
//go:embed Pattern
```

Pattern是文件路径通配符，支持以下通配符：

| 通配符        | 释义                                                                  |
| ------------- | --------------------------------------------------------------------- |
| ?             | 代表任意一个字符（不包括半角中括号）                                  |
| *             | 代表0至多个任意字符组成的字符串（不包括半角中括号）                   |
| [...]和[!...] | 代表任意一个匹配方括号里字符的字符，!表示任意不匹配方括号中字符的字符 |
| [a-z]、[0-9]  | 代表匹配a-z任意一个字符的字符或是0-9中的任意一个数字                  |
| **            | 部分系统支持，`*`不能跨目录匹配，`**` 可以。当前与*同义。         |

Pattern，从项目根目录开始，通常不需要使用/，目录分隔符使用/。路径是文件，仅嵌入文件内容，路径是目录，嵌入目录下的全部文件包括递归子目录。

//go:embed 指令只能用于package范围，不用用于函数范围。

## 嵌入程序的数据类型

支持三种类型：

- []byte，任何文件内容，适合单文件。
- string，字符串文件内容，不适合二进制文件（例如图片，声音），适合单文件。
- embed.FS，文件系统，适合嵌入目录

## 单文件嵌入示例

示例代码：

```go
import (
	_ "embed"
	"fmt"
)

//go:embed file/robots.txt
var robots string

//go:embed file/logo.png
var logo []byte

func EmbedFile() {
	fmt.Println(robots)
	fmt.Println(logo)
}
```

file/robots.txt

```
User-agent: Baiduspider
Disallow:
User-agent: *
Disallow: /
```

file/logo.png

测试：

```go
func TestEmbedFile(t *testing.T) {
	EmbedFile()
}

> go test -run EmbedFile
User-agent: Baiduspider
Disallow:
User-agent: *
Disallow: /
[137 80 78 71 .....]
PASS
ok      github.com/han-joker/goExample/em       0.032s
```

### 举例2

```go
//go:embed hello.txt 

var content string 

//go:embed hello.txt 

var contentBytes []byte
```

**代码详解**

**`//go:embed hello.txt`**

- `//go:embed` 是一个指令，用于指定要嵌入的文件或目录。
- `hello.txt` 是要嵌入的文件路径，它必须相对于当前 Go 源文件的位置。
- **这行指令告诉编译器在构建二进制文件时**，将 `hello.txt` 文件的内容嵌入到程序中。

**`var content string`**

- 定义一个 `string` 类型的变量 `content`，用于存储嵌入文件的内容。
- 如果嵌入的文件是文本文件，其内容会被存储为一个字符串，支持直接访问。

**`var contentBytes []byte`**

- 定义一个 `[]byte` 类型的变量 `contentBytes`，用于存储嵌入文件的内容。
- 文件内容会被存储为字节切片（`[]byte`），适用于需要处理二进制数据或高效处理文件内容的场景。

## 目录嵌入示例

目录必须使用embed.FS类型嵌入。

示例：

```go
// 嵌入目录
//
//go:embed files
var files embed.FS

func EmbedDir() {
	// 获取目录下的全部文件
	entries, err := files.ReadDir("files")
	if err != nil {
		log.Fatal(err)
	}

	// 以此输出每个文件的信息
	for _, entry := range entries {
		info, _ := entry.Info()
		fmt.Println(entry.Name(), entry.IsDir(), info.Size())
	}

	// 读取文件内容
	content, _ := files.ReadFile("files/robots.txt")
	fmt.Println(string(content))
}
```

测试：

```
func TestEmbedDir(t *testing.T) {
	EmbedDir()
}

> go test -run EmbedDir
logo.png false 45586
robots.txt false 64
User-agent: Baiduspider
Disallow:
User-agent: *
Disallow: /

PASS
ok      goSyntax        0.030s

```

**示例2**

```go
//go:embed static/* 

var staticFiles embed.FS
```

这段代码利用 Go 的 `embed` 包将目录 `static` 下的所有文件嵌入到程序中。以下是详细的分解和解释：

------

**代码解析**

**`//go:embed static/\*`**

- `//go:embed` 指令：
  - 告诉 Go 编译器将指定路径下的文件嵌入到程序中。
- `static/*` 匹配模式：
  - 表示将 `static` 目录下的所有文件（包括子目录中的文件）嵌入。
  - `*` 是通配符，用来匹配目录下的所有文件。
  - 仅会匹配 **文件**，不会匹配空目录。
- 文件路径是相对于声明该代码的 Go 源文件的相对路径。

------

**`var staticFiles embed.FS`**

- 定义变量：
  - 变量 `staticFiles` 的类型是 `embed.FS`，表示一个只读的虚拟文件系统。
  - `embed.FS` 是 `embed` 包提供的一个类型，用于管理嵌入的文件或目录。
- 作用：
  - 嵌入的文件可以通过 `embed.FS` 提供的方法（如 `ReadFile` 和 `WalkDir`）访问。

------

**示例目录结构**

假设项目的目录结构如下：

```
project/
├── main.go          // 当前代码文件
└── static/
    ├── hello.txt
    ├── world.txt
    └── images/
        └── logo.png
```

------

**如何访问嵌入的文件**

以下是一些常见的使用方式：

**1. 读取文件内容**

使用 `ReadFile` 方法读取文件内容：

```go
package main

import (
	"embed"
	"fmt"
)

//go:embed static/*
var staticFiles embed.FS

func main() {
	// 读取 static/hello.txt 文件内容
	content, err := staticFiles.ReadFile("static/hello.txt")
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Println("File content:", string(content))
}
```

运行结果： 如果 `static/hello.txt` 的内容是 `Hello, embed!`，输出：

```
File content: Hello, embed!
```

------

**2. 遍历目录**

使用 `fs.WalkDir` 遍历嵌入的目录及其内容：

```go
package main

import (
	"embed"
	"fmt"
	"io/fs"
)

//go:embed static/*
var staticFiles embed.FS

func main() {
	// 遍历 static 目录
	fs.WalkDir(staticFiles, "static", func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			fmt.Println("Directory:", path)
		} else {
			fmt.Println("File:", path)
		}
		return nil
	})
}
```

运行结果：

```
Directory: static
File: static/hello.txt
File: static/world.txt
Directory: static/images
File: static/images/logo.png
```

------

**注意事项**

1. **路径匹配规则**：
   - 文件路径必须严格匹配嵌入时的相对路径。
   - 例如，`static/hello.txt` 不能写成 `hello.txt`，否则会报错。
2. **空目录不会被嵌入**：
   - 如果 `static` 目录中有子目录，但子目录是空的，则该子目录不会被嵌入到二进制文件中。
3. **嵌入的是文件的快照**：
   - 嵌入的文件内容是编译时的快照，程序运行时无法动态修改这些内容。
4. **增加二进制文件大小**：
   - 所有嵌入的文件内容都会被打包到程序的二进制文件中，因此要避免嵌入过大的文件或非必要的文件。

------

**适用场景**

- 嵌入静态资源（HTML、CSS、JS、图片等）。
- 嵌入配置文件或模板文件。
- 构建独立的、无需额外依赖的可执行文件。

通过这种方式，Go 程序可以在运行时访问嵌入的文件，而无需依赖外部文件或路径配置，非常适合部署到生产环境。

## embed.FS支持的方法

```go
type FS
// 打开文件
func (f FS) Open(name string) (fs.File, error)
// 读取目录
func (f FS) ReadDir(name string) ([]fs.DirEntry, error)
// 读取文件
func (f FS) ReadFile(name string) ([]byte, error)

```

## 示例：静态http服务器

static内容：

```
/index.html
/img/logo.png
/css/style.css
/js/script.js
```

嵌入静态文件目录，启动http服务器，等待请求：

```go
//go:embed static
var static embed.FS

// 启动服务器
func StaticEmbedServer() {
	// 获取嵌入的static子目录作为文件系统
	staticFS, _ := fs.Sub(static, "static")
	// 基于static的FS，创建 http.FS
	// 基于http.FS，创建 http.FileServer
	// 启动监听 :8080
	http.ListenAndServe(":8080", http.FileServer(http.FS(staticFS)))
}
```

```shell
func TestStaticServer(t *testing.T) {
	StaticServer()
}

> go test -run StaticServer

```

浏览器请求：

localhost:8080

运行中我们可以任意更改static中的内容，不影响静态服务器。

### 作为对比，我们在做一个运行时，读取静态文件内容的http服务器

代码：

```go
// 非嵌入，运行时读取静态文件的服务器
func StaticRuntimeServer() {
	// os.DirFS 基于操作系统的目录文件系统
	staticFS := os.DirFS("static")
	http.ListenAndServe(":8081", http.FileServer(http.FS(staticFS)))
}
```

```
func TestStaticRuntimeServer(t *testing.T) {
	StaticRuntimeServer()
}

> go test -run StaticRuntimeServer

```

浏览器请求：

localhost:8081

运行中我们更新static内容，发现访问404错误了。

## 语法细节

* 一定要导入embed包

- 会自动忽略版本控制目录：

  - .git
  - .svn
  - .bzr
  - .hg
  - .idea不会被忽略
- dir 和 dir/* 有差异，常用的dir

  - dir 可以嵌入空目录
  - dir/* 不会嵌入空目录
  - dir 会忽略隐藏文件
  - dir/* 不会忽略隐藏文件
- 注意相同文件嵌入不同变量的资源副本问题（浪费）
- 过大的文件会导致二进制程序过大，注意性能问题

## fs.Sub函数详解

`fs.Sub` 是 Go 标准库 `io/fs` 包中的一个函数，用于基于现有文件系统 (`fs.FS`) 创建一个新的子文件系统 (`fs.FS`)，该子文件系统从指定的子路径开始。它是 `io/fs` 包中常用的功能，用来处理嵌套的文件目录。

------

**函数定义**

```go
func Sub(fsys FS, dir string) (FS, error)
```

**参数**

1. ```
   fsys FS:
   ```

   - 原始文件系统，可以是一个实现了 `fs.FS` 接口的对象（例如 `embed.FS`）。

2. ```
   dir string:
   ```

   - 文件系统中的子路径，表示新的子文件系统的根路径。

**返回值**

1. ```
   (FS, error)
   ```

   :

   - 成功时返回一个新的 `fs.FS` 实例，表示从 `dir` 开始的子文件系统。
   - 如果 `dir` 不存在，或者不是一个目录，会返回错误。

------

**主要用途**

- 从一个嵌入文件系统或文件系统抽象中，提取出一个子目录的文件视图。
- 常见于使用 `embed` 包嵌入多个文件或目录时，从嵌入的根目录中分离特定子目录的内容。

------

**使用场景**

**示例：静态文件服务器**

假设项目目录结构如下：

```
project/
├── main.go          // 当前代码文件
└── static/
    ├── css/
    │   └── style.css
    └── js/
        └── app.js
```

我们使用 `fs.Sub` 提取 `static/css` 目录作为子文件系统：

```go
package main

import (
	"embed"
	"io/fs"
	"net/http"
)

//go:embed static
var static embed.FS

func main() {
	// 从嵌入的文件系统中提取 static/css 目录
	cssFS, err := fs.Sub(static, "static/css")
	if err != nil {
		panic(err)
	}

	// 使用提取的子文件系统创建 HTTP 文件服务器
	http.Handle("/css/", http.StripPrefix("/css/", http.FileServer(http.FS(cssFS))))

	// 启动 HTTP 服务器
	http.ListenAndServe(":8080", nil)
}
```

**运行结果**

- 浏览器访问 `http://localhost:8080/css/style.css` 会返回嵌入的 `static/css/style.css` 文件的内容。

------

**错误处理**

`fs.Sub` 可能返回的错误包括：

1. 目录不存在：
   - 如果 `dir` 参数指定的子路径不存在，则返回 `fs.ErrNotExist` 错误。
2. 路径不是目录：
   - 如果 `dir` 参数指向的是文件而非目录，则返回 `fs.ErrInvalid` 错误。

**示例**

```go
cssFS, err := fs.Sub(static, "static/css")
if err != nil {
    if errors.Is(err, fs.ErrNotExist) {
        fmt.Println("Directory does not exist")
    } else if errors.Is(err, fs.ErrInvalid) {
        fmt.Println("Path is not a directory")
    } else {
        fmt.Println("Unexpected error:", err)
    }
    return
}
```

------

**注意事项**

1. 子目录路径的合法性：
   - 子目录路径必须存在，并且是基于 `fs.FS` 的根路径的有效相对路径。
2. 子文件系统权限：
   - 新的子文件系统继承了原始文件系统的只读特性。
3. 动态性：
   - 嵌入的文件内容在编译时确定，运行时无法动态改变。

------

**总结**

`fs.Sub` 是一个实用工具函数，适合在嵌入文件或抽象文件系统中操作子目录。它的优点在于：

- 简化了子目录的管理。
- 提供了一种一致的方式访问嵌套目录的内容。
- 与 `embed` 包和 `http.FileServer` 配合使用非常高效。
