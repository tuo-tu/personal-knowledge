#### nginx是什么？

**Nginx**（读作 *engine-x*）是一个 **高性能的 Web 服务器和反向代理服务器**，同时也可以做 **负载均衡器**、**缓存服务器**、**邮件代理**。

#### 什么叫web服务器？

> **Web 服务器（Web Server）** 是一种 **提供网页服务的软件或硬件系统**。

**网站服务器**（Web Server）是一种用于存储、处理和传输**网页内容**的计算机程序或设备。它的主要功能是**接收客户端（如浏览器）的请求，并将所需的网页资源（如HTML、CSS、JavaScript文件等）传输回客户端。**

**工作流程（简化理解）**

1. 用户在浏览器输入 `http://example.com`
2. 浏览器发起 HTTP 请求 → 到达 Web 服务器（如 Nginx）
3. Web 服务器判断：
   - 如果是静态文件 → 直接返回
   - 如果是动态接口 → 转发给后端应用（Go/Java/Node.js）
4. 后端返回结果 → Web 服务器再发回给浏览器
5. 用户看到网页或数据

#### node.js是什么？

**Node.js** 是一个基于 **Chrome V8 引擎** 的 **JavaScript 运行环境**。

- 以前 JavaScript 只能运行在浏览器里（前端脚本语言）。
- 有了 Node.js，就可以在 **服务器端** 运行 JavaScript 了。
- 简单来说，Node.js 让 **JavaScript 既能写前端，又能写后端**。

**生态**

- **npm（Node Package Manager）**：Node.js 的包管理工具，世界上最大的软件包生态系统。
- **框架丰富**：Express、Koa、NestJS、Egg.js 等，开发效率高。

#### html中head和body的区别？

**`<head>`**

- 放置的是 **网页的配置信息/元信息 (metadata)**，这些内容不会直接显示在页面上，但会影响页面的表现和行为。

**`<body>`**

- 放置的是 **网页的可见内容**，也就是用户在浏览器里能看到、能交互的部分。

#### div是什么？

div 标签是 **HTML 中最常用的块级元素**，主要用于对网页内容进行分区和布局。它本身没有语义，只是一个通用的容器，用来把元素分组，方便样式（CSS）控制或脚本（JavaScript）操作。

**与 `<span>` 的区别**

- `<div>` → 块级元素，用于大块内容的分区。
- `<span>` → 行内元素，用于小范围的内容标记。

#### 渲染是什么意思？

👉 **把数据/代码 转换成 用户可见或可理解的结果 的过程**。

**1. 在前端（网页开发）中**

渲染 = 把 HTML、CSS、JavaScript 代码转化为页面，显示在浏览器中。

例子：

```html
<div style="color:red;">你好</div>
```

浏览器渲染后 → 在页面上显示一行 **红色文字 "你好"**。

这里浏览器做了几件事：

1. 解析 HTML → 生成 DOM 树。
2. 解析 CSS → 生成 CSSOM。
3. 合并成渲染树。
4. 计算位置、大小、颜色。
5. 把像素绘制到屏幕上。

**2. 在后端/模板引擎中**

渲染指的是 **把数据套用到模板中，生成最终的 HTML 字符串**。

例子（Go 的 `html/template` 模板）：

```go
Hello, {{.Name}}!
```

数据：`Name = "Tom"`
 渲染结果：`Hello, Tom!`

**3.在图形学/游戏中**

渲染是 **把三维模型、材质、光照等计算并绘制成二维图像** 的过程。
 比如游戏引擎里，3D 世界经过渲染，最终显示在屏幕上的就是画面。

------

**4.在大白话里的总结**

- 前端：把代码变成网页。
- 后端：把数据填到模板里，生成内容。
- 图形学：把 3D 世界画成 2D 画面。

#### RESTful API设计规范是什么?

很好 👍，RESTful API 设计规范是后端开发中非常核心的一块。
 我给你梳理一个 **系统性、面试常见的 RESTful API 设计规范总结**：

------

一、REST 的概念

- **REST** = Representational State Transfer（表述性状态转移），是一种**架构风格**，不是标准。
- 核心思想：
  - 用 **资源（Resource）** 来建模（例如用户、订单、商品）。
  - 用 **HTTP 方法** 来表示动作（CRUD）。
  - API 应该 **简洁、统一、无状态**。

------

二、URL 设计规范

1. 使用名词（资源）而不是动词

❌ 错误示例：

```
GET /getUserInfo
POST /createUser
```

✅ 正确示例：

```
GET /users        # 获取用户列表
GET /users/123    # 获取 ID=123 的用户
POST /users       # 创建用户
PUT /users/123    # 更新用户
DELETE /users/123 # 删除用户
```

2. 使用复数表示资源

```
/users  ✅
/user   ❌
```

3. 层级关系用路径表示

```
GET /users/123/orders/456  # 获取某用户的某订单
```

4. 使用查询参数过滤、排序、分页

```
GET /users?page=2&limit=20&sort=created_at&status=active
```

------

三、HTTP 方法与语义

| 方法   | 含义             | 幂等性 | 示例              |
| ------ | ---------------- | ------ | ----------------- |
| GET    | 获取资源         | ✅      | GET /users        |
| POST   | 创建资源         | ❌      | POST /users       |
| PUT    | 更新资源（整体） | ✅      | PUT /users/123    |
| PATCH  | 更新资源（部分） | ✅      | PATCH /users/123  |
| DELETE | 删除资源         | ✅      | DELETE /users/123 |

------

四、HTTP 状态码规范

常用的返回码：

- `200 OK`：请求成功
- `201 Created`：资源创建成功
- `204 No Content`：删除成功，无返回体
- `400 Bad Request`：请求参数错误
- `401 Unauthorized`：未认证（需要登录）
- `403 Forbidden`：权限不足
- `404 Not Found`：资源不存在
- `409 Conflict`：资源冲突（如用户名已存在）
- `500 Internal Server Error`：服务器错误

------

五、返回结果规范

成功返回

```json
{
  "code": 0,
  "message": "success",
  "data": {
    "id": 123,
    "name": "Tom"
  }
}
```

失败返回

```json
{
  "code": 4001,
  "message": "用户名已存在"
}
```

> `code` 建议用业务码，区分不同错误。

------

六、其他设计要点

1. **版本控制**

   - 在 URL 或 Header 中体现版本：

   ```
   GET /api/v1/users
   ```

2. **鉴权**

   - 使用 Token（JWT、OAuth2）而不是在 URL 里放敏感信息。

3. **幂等性保证**

   - 对于支付、下单接口，常用 **幂等性 Key** 来防止重复提交。

4. **统一错误码 & 文档**

   - 便于前端调用和调试。

------

✅ 总结一句话：
 **RESTful API = 用 URL 定义资源，用 HTTP 方法定义操作，用状态码表达结果，返回统一格式的数据。**

#### 幂等性是什么意思？

好问题 👍，**幂等性（Idempotence）** 是面试和实际开发里经常考察的概念。

------

1. 定义

幂等性是一个数学和计算机科学里的概念：

👉 **一次或多次操作产生的结果相同，不会因为重复执行而产生副作用。**

------

2. 在 HTTP/REST API 中

HTTP 标准里对方法的幂等性有规定：

- **GET**：幂等（查多少次都是一样的，不改变资源）。
- **PUT**：幂等（多次更新同一个资源为相同数据，结果一样）。
- **DELETE**：幂等（删一次和删多次效果相同——资源不存在）。
- **POST**：非幂等（多次提交可能创建多个资源）。

------

3. 举例说明

(1) GET 幂等

```http
GET /users/123
```

- 第一次请求：返回用户信息
- 第二次请求：返回结果一样，不会额外改变数据

(2) DELETE 幂等

```http
DELETE /users/123
```

- 第一次删除：用户被删除
- 第二次删除：用户已经不存在 → 结果还是“已删除”状态

(3) PUT 幂等

```http
PUT /users/123  { "name": "Tom" }
```

- 无论请求多少次，用户的名字都会是 Tom，不会再变化

(4) POST 非幂等

```http
POST /orders  { "item": "book" }
```

- 第一次请求：创建订单 101
- 第二次请求：又创建订单 102
- 结果不同，不是幂等的

------

4. 在实际业务中的应用

有些场景必须保证幂等性，否则会造成严重问题，比如：

- **支付接口**：用户点两次「支付」，不能重复扣款。
- **订单接口**：用户点两次「下单」，不能生成两个订单。

常见解决方案：

1. **唯一请求 ID（幂等性 key）**
   - 客户端生成一个唯一 ID（比如 UUID），同样的 ID 的请求只能成功一次。
2. **数据库唯一约束**
   - 利用唯一索引（如订单号唯一）来防止重复插入。
3. **分布式锁**
   - 在关键资源上加锁，避免重复操作。

------

✅ 总结一句话：
 **幂等性 = 重复请求多次，和请求一次的效果一样。**
 它能保证系统在网络抖动、用户重复操作、接口重试的情况下，数据不会被破坏。

#### 前端如何跟后端交互？

可以 👍 我用一个 **非常简单的例子** 来说明前端和后端是如何交互的。

------

1. **基本思路**

- **后端** 提供接口（API），比如 `http://api.example.com/users`。
- **前端**（网页、小程序、APP）通过 **HTTP 请求** 调用接口，把数据要过来或者发给后端。
- **双方通过 JSON 这种数据格式交流**。

------

2. **举个例子**

**后端有一个接口：**

```http
GET http://api.example.com/users/123
```

返回数据：

```json
{
  "id": 123,
  "name": "Tom",
  "age": 20
}
```

------

**前端调用方式（以 JavaScript 为例）：**

```javascript
// 浏览器或前端 JS 调用后端接口
fetch("http://api.example.com/users/123")
  .then(response => response.json())  // 把结果转成 JSON
  .then(data => {
    console.log(data);  // { id: 123, name: "Tom", age: 20 }
    document.getElementById("username").innerText = data.name;
  });
```

📌 过程：

1. 前端发起请求（fetch 或 axios）。
2. 浏览器把请求发送给后端服务器。
3. 后端服务器处理请求，从数据库拿数据，返回 JSON。
4. 前端拿到 JSON，把内容渲染到页面上。

------

3. **另一个例子：前端提交数据给后端**

**后端接口：**

```http
POST http://api.example.com/users
```

请求体（前端提交的数据）：

```json
{
  "name": "Alice",
  "age": 22
}
```

返回：

```json
{
  "id": 124,
  "name": "Alice",
  "age": 22
}
```

**前端调用：**

```javascript
fetch("http://api.example.com/users", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ name: "Alice", age: 22 })
})
.then(res => res.json())
.then(data => console.log("新建成功:", data));
```

------

✅ **一句话总结**：
 前端和后端交互，就是 **前端发 HTTP 请求 → 后端处理并返回 JSON → 前端解析结果并展示**。

#### 重点讲一下如何通过 HTTP 请求 调用接口，把数据要过来或者发给后端。

好嘞 👍 我重点给你讲 **前端通过 HTTP 请求调用后端接口** 的过程，抓住“请求–响应”的核心。

------

1. HTTP 请求的核心要素

当前端要和后端交互时，本质就是发一个 **HTTP 请求**，主要包含几个部分：

1. **请求方法（Method）**：说明动作
   - `GET` → 获取数据
   - `POST` → 新增数据
   - `PUT/PATCH` → 修改数据
   - `DELETE` → 删除数据
2. **URL（地址）**：接口地址
   - 例子：`http://api.example.com/users/123`
3. **请求头（Headers）**：额外说明信息
   - `Content-Type: application/json` → 请求体是 JSON
   - `Authorization: Bearer <token>` → 登录后的身份凭证
4. **请求体（Body）**：要发给后端的数据（仅 POST/PUT/PATCH 用）

------

2. 获取数据（GET 请求）

例子：前端想拿到用户信息

```javascript
fetch("http://api.example.com/users/123", {
  method: "GET"
})
.then(res => res.json())
.then(data => {
  console.log("用户信息:", data);
});
```

👉 请求过程：

- 前端：`GET /users/123`
- 后端：查数据库 → 返回 JSON
- 前端：解析 JSON → 更新到页面

------

3. 发送数据（POST 请求）

例子：前端提交表单，新建用户

```javascript
fetch("http://api.example.com/users", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ name: "Alice", age: 22 })
})
.then(res => res.json())
.then(data => {
  console.log("创建成功:", data);
});
```

👉 请求过程：

- 前端：`POST /users`，请求体 `{name: "Alice", age: 22}`
- 后端：存数据库 → 返回新用户数据
- 前端：拿到返回结果 → 提示用户“创建成功”

------

4. 修改数据（PUT/PATCH 请求）

例子：修改用户信息

```javascript
fetch("http://api.example.com/users/123", {
  method: "PUT",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ age: 25 })
})
.then(res => res.json())
.then(data => {
  console.log("更新成功:", data);
});
```

------

5. 删除数据（DELETE 请求）

例子：删除用户

```javascript
fetch("http://api.example.com/users/123", {
  method: "DELETE"
})
.then(res => {
  if (res.status === 204) {
    console.log("删除成功");
  }
});
```

------

✅ 总结一句话

**前端调用后端接口，就是构造一个 HTTP 请求（URL + 方法 + 参数 + 头 + 体），发送给后端 → 后端返回响应（通常是 JSON）→ 前端解析并展示。**

------

要不要我帮你整理一个 **常用 HTTP 请求的速查表（GET/POST/PUT/DELETE 对比 + 示例）**？这样你以后写接口调用就可以直接套用。

#### npm是什么？

好的 👍 我来帮你解释 **NPM**。

------

**1. NPM 是什么**

**NPM** 全称 **Node Package Manager**，直译就是 **Node.js 的包管理器**。

- 它是 **Node.js 官方默认的包管理工具**。
- 主要用来 **安装、管理和发布 JavaScript/TypeScript 的第三方库或工具**。

------

**2. NPM 能做什么**

1. **安装依赖**

   ```bash
   npm install express
   ```

   👉 会下载 `express` 库到项目里，供你在代码中使用：

   ```js
   const express = require("express");
   ```

2. **管理依赖版本**

   - NPM 会把项目依赖写到 `package.json` 里
   - 版本号管理规则：`^1.2.3`、`~1.2.3` 等

3. **运行脚本**
    在 `package.json` 定义脚本：

   ```json
   {
     "scripts": {
       "start": "node app.js",
       "dev": "nodemon app.js"
     }
   }
   ```

   执行：

   ```bash
   npm run dev
   ```

4. **发布自己的包**

   - 可以用 `npm publish` 把自己写的库发布到 NPM 官网，供别人使用。

------

**3. 常用命令**

| 命令                    | 作用                              |
| ----------------------- | --------------------------------- |
| `npm init -y`           | 初始化项目（生成 `package.json`） |
| `npm install <包名>`    | 安装依赖（简写 `npm i`）          |
| `npm install <包名> -g` | 全局安装                          |
| `npm install`           | 根据 `package.json` 安装所有依赖  |
| `npm uninstall <包名>`  | 卸载依赖                          |
| `npm update <包名>`     | 更新依赖                          |
| `npm run <脚本名>`      | 执行 `package.json` 里定义的脚本  |
| `npm publish`           | 发布包到 npm 仓库                 |

------

**4. 相关的东西**

- **package.json** → 项目的依赖清单（记录需要哪些包、版本号、脚本等）。
- **node_modules** → 存放安装好的依赖库的目录。
- **npm registry** → 官方仓库，所有包都从这里下载。

------

✅ **一句话总结**：
 **NPM 是 JavaScript/Node.js 的包管理工具，用来下载、安装、管理和发布库或工具。**

#### vite是什么？



我的项目goland未配置代理服务。已配置

前端：未安装ws，使用vscode替代。

目前的主要任务：做易养天年的通讯板块。

#### MCP协议？

#### 前端服务和后端服务，在关闭的时候一般先关闭哪个?

👉 **先关闭前端服务，再关闭后端服务**