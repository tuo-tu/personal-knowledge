### 计算机网络

#### TCP协议（基于有连接的可靠传输协议）

TCP协议的头部信息主要包括：源端口、目的端口、SYN、seq、ack、ACK、FIN

#### 请描述一下三次握手？

首先是由客户端主动发起建立连接的请求。

1. 第一次握手是**客户端发起连接请求**。客户端会将自己的SYN标志位置为1，并且随机产生一个序列号seq。然后客户端会将该数据包发送给服务端，发送完以后客户端会进入一个**同步已发送**的状态。

2. 第二次握手是**服务端进行确认**的过程。服务端在接收到客户端的连接请求后，将自己的SYN和ACK标志位置为1，然后将接收到的seq序列号加上1赋值自己的确认号ack，并且服务端也会产生一个随机的序列号seq。然后服务端会将该确认包发送给客户端，这个时候服务端会进入到一个**同步已接收**的状态。

3. 第三次握手是**客户端进行确认**的过程。客户端收到确认后，将自己的ACK标志位置为1，并且将自己的seq序列号加1，将接收到的seq序列号加上1赋值给自己的确认号ack。然后客户端会将该确认包发送给服务端。

完成上面的三次握手后，客户端和服务端都会进入到**连接已建立**的状态，这时候就可以进行数据传输了。

为什么不握手2次？因为客户端发送的消息有可能没被服务端收到，服务端最后接收到以后会不断发送确认消息，浪费资源

#### 请描述一下四次挥手？

四次挥手就是断开TCP连接的过程，这个动作呢可以由客户端或者服务端任意一方来执行，那我们假设由客户端来主动关闭这个连接。

1. 第一次挥手是**客户端请求断开连接**，客户端将自己的终止标志位FIN置为1，并且设置一个序列号seq，接着将这个报文段发送给服务端，自己呢进入**终止等待1**的状态；
2. 第二次挥手是**服务端进行确认**的过程，服务端收到请求释放连接的消息后，将自己的**ACK标志位**置为1，确认序号为收到序号加1，然后将该报文段发送给客户端，自己进入**等待关闭**的状态，客户端收到服务端的确认后进入**终止等待2**状态；
3. 第三次挥手是**服务端请求断开连接**，服务端将自己的**FIN标志位**置为1，然后发送数据包给客户端，自己进入**最后确认**的状态；
4. 第四次挥手是**客户端进行确认**的过程，客户端收到请求释放连接的消息后，向服务端发送确认信息，自己会等待一段时间（2MSL）再关闭连接，服务端收到确认消息后立刻关闭连接。

为什么要等待2MSL？因为客户端最后的确认有可能没被服务端收到，服务端进行超时重传，从而浪费服务端资源

#### TCP为什么四次挥手比三次握手要多一次？

1. 因为TCP连接断开时，客户端和服务器都需要**单独关闭自己的发送方向**，这两个方向的关闭是需要独立完成的，所以需要四次挥手。
2. 客户端和服务端都有数据传输，需要等数据传输完成以后再关闭连接，因此需要4次挥手。

#### 描述一下浏览器发送HTTP请求的过程？

1. 首先浏览器会向域名解析服务器发送域名，DNS服务器解析完成以后会返回一个IP地址；
2. 浏览器拿到ip地址后，就明确了需要连接的web服务器，然后和服务器进行三次握手，建立TCP连接；
3. 建立好连接后，开始发起HTTP请求；
4. web服务器收到请求以后，进行响应，返回html；
5. 浏览器在拿到服务器返回的html后，解析数据，加载资源；
6. 然后浏览器就可以关闭TCP连接了。

### 操作系统

#### 进程和线程的区别？

1. 概念：进程是运行中的程序，是程序的一次执行过程，而线程只是进程内的一个**执行单元**，一个进程可以拥有多个线程；
2. 基本单位：进程是**资源分配**的基本单位，线程是**CPU 调度和执行**的基本单位；
3. 资源： 进程拥有独立的资源，而线程没有拥有资源，但可以共享进程的资源。

4. 通信：进程有独立的地址空间，进程之间通过IPC进行通信，而进程通过**共享内存**来通信；

#### 进程间的通信方式？

管道、命名管道、信号、消息队列、共享存储等

#### 线程间的通信？

共享内存、锁、条件变量、信号量等

### Golang相关

#### 描述一下map的底层实现？

golang中的map的底层实际上就是哈希表，他的底层实现是**数组+链表**的方式。

链表是指桶与溢出桶之间通过指针相连。

1. 数组的每一个元素代表一个桶，每一个桶可以存储8个键值对；
2. 超出桶的容量以后呢，新的键值对会被放到溢出桶里面；
3. 当元素太多/溢出桶过多，就会触发扩容机制；
4. 元素过多会触发翻倍扩容，溢出桶过多会触发等量扩容（桶的数量不变，只是内存的重新分配）；

#### 描述一下slice的底层实现？

slice的底层是一个**三元组结构**，包括长度、容量、指向底层数组的指针。

切片的容量 = 从切片的起始位置到底层数组末尾的元素个数

1. 切片实际上是对底层数组的某个片段的使用；

2. 由于切片是可以动态增长的，因此当增长到超过切片容量时，会触发扩容机制；

3. 扩容时，会创建一个新的更大的数组，并**复制旧数组的数据**；

4. **扩容策略：**
- 如果新容量大于原容量的2倍，则直接使用**新容量**作为目标容量；
  
- 如果原slice容量 < 256，它会直接**翻倍**容量；
  
- 如果原slice容量 > 256，扩容时会采取**逐步增加**的策略，每次容量**增加**（旧容量+3*256）/4，直到满足目标容量。

#### 描述一下GMP模型？

暂略

#### 描述一下GC机制？

Go的最新版本采用三色标记法+混合写屏障，在整个垃圾回收的过程中，**不需要启动STW**，效率很高。

### 数据结构与算法

#### 归并排序是什么？为什么时间复杂度是O(nlog(n))？

排序过程主要分为拆分和合并两个步骤。

1. 先不断拆分数组成为多个只有一个元素最小数组，然后最小数组两两比较进行排序，最后再合并成排好序的大数组。
2. 拆分时每次拆一半，所以是logN，合并时，因为拆成了二叉树，每层元素都是N，需要遍历logN层，所以时间复杂度就是NlogN。

#### 讲一讲单例模式如何保证线程安全？讲一讲抽象工厂是什么？

1. go语言中使用`sync.Once` 保证某段代码只执行一次；底层应该是使用了原子操作和锁。
2. 抽象工厂模式，比如游戏中人和怪兽代表不同的阵营，他们都可以攻击、躲避、说话等，那么这些动作呢就代表不同的方法，人和怪兽都有各自不同的实现。然后再抽象出一个工厂接口，这个工厂可以给人用，也可以给怪兽用，那么我们就可以在使用过程中选择生产人还是生产怪兽，然后生产的人和怪兽再去完成各自的动作。

### golang中的协程安全？

可以使用channel、锁机制、 sync.Once、 sync.Map、 atomic来避免

### 如何检测和避免data race？

检测：多个 goroutine 并发地访问同一块内存（资源），使用 `-race` 选项编译或运行。

避免：使用上述的协程安全方式。

### 理解多协程下死锁的产生并知道如何避免？

产生：两个或多个 goroutine **互相等待对方释放资源**，

避免：

1. 始终保持**锁获取的顺序一致**
2. 尽量缩小**锁的持有时间**
3. 使用channel作为通信手段
4. 可以在使用锁之前使用trylock尝试加锁

### 掌握golang多路复用并发处理的技术？

`select` 语句：多 channel 监听（最常见）

### golang的性能分析及调优方式？

使用pprof

### golang的web、orm、cache及socket框架？

cache：redis

socket：gorilla/websocket

### http协议，能根据其定义进行一定的系统故障诊断？

状态码

<img src="C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250715155531710.png" alt="image-20250715155531710" style="zoom:50%;" />

### http和https的区别？

HTTP 是明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。

在 HTTP 上加入 SSL/TLS 加密层，是安全通信。

### 红黑树与B+树了解么？为什么innoDB使用B+树而不是使用红黑树

1. 红黑树是二叉平衡搜索树， B+树是多叉平衡搜索树
2. 红黑树所有节点都存数据，B+树只有叶子节点存数据
3. 既然是多叉呢，B+树的高度肯定较低，**查询起来肯定比较快**。比如一个范围查询，红黑树需要扫描整棵树，而B+树只需要扫描叶子节点。

###  Linux 命令行工具？

**touch：**主要用于 **创建空文件** 或 **更新文件的时间戳**。

**rm：**用于删除一个文件或者目录。

**rmdir：**用于删除空的目录。

**mv：**为文件或目录**改名**，或者移动文件和目录。

**cp：**用于复制文件或目录。

**cat、more、less比较**：可以打印文件。

- `cat` 命令用于将文件内容一次性显示到终端，适合查看小型文件的全部内容。
- `more` 命令**按页显示**文件内容，只能向后翻滚。
- `less` 命令支持**向上和向下**滚动。

**grep** ：文本搜索工具

ps -aux | grep apache等

**ps命令：**查找进程，可配合grep使用

**`sed` ：**支持对文本进行**替换、删除、插入、行编辑**

**`awk` ：**是一种编程语言，支持**格式化输出、计算、统计**等，可以做简单的统计分析。

### Docker工具？

docker run：

docker ps：列出正在运行的容器。

docker inpect 查看容器详细信息

docker exec 进入到容器中执行命令

```sh
docker exec -it abc123 /bin/bash
```

`docker images` 是用于查看本地已下载的 Docker 镜像的命令。

docker rmi 是删除镜像，不是删除容器。

`docker export`：导出容器文件系统快照，和import配对

**集群部署mysql：**

在命令里面要指定**映射端口、日志目录、数据目录、配置目录**的映射、**密码**；

从节点会多一个 `--link`

**持久化：**

- 使用docker run -v 命令去挂载目录

-  使用数据卷volumes：使用 --mount选项，实现数据卷挂载

- bind mounts：将宿主机上的任意位置文件或目录挂载到容器中

**docker-compose：**

使用docker-compose up命令启动

### 服务网格

服务网格（Service Mesh）是一种专用的基础设施层，用于管理微服务之间的通信。

![img](https://ask.qcloudimg.com/http-save/yehe-3106400/3a3c8bc7978c1b3060741364cd8a0e39.png)

## 一零悦动（预）

### 快排思路，堆排思路？

**1、快速排序（Quick Sort）**

**核心思想**：分治法 + 基准元素划分

- 选一个基准元素（pivot）
- 将数组分成两部分：小于基准的放左边，大于基准的放右边
- 递归处理左右两部分

**2、堆排序（Heap Sort）**

**核心思想**：利用堆数据结构的特性

- 将数组构建成大顶堆（父节点大于子节点）
- 反复取出堆顶（最大值）放到数组末尾
- 调整剩余元素为新堆

### 智力题：两个小球，有100层楼，怎样测试小球到哪一层楼会碎？

最多14次测试

### 要是前端界面访问的时候出现500错误，怎样去检查？

500是服务器内部错误。

打开浏览器开发者工具（F12 ）

查看请求的 **URL、参数、请求方式（GET/POST 等）**。

**1. 先确认错误类型**

- 500 错误是**服务器端出错**，不是前端代码直接导致的（前端最多只会触发这个错误，但问题根源在服务器）。
- 先排除前端缓存问题：按 `Ctrl+Shift+R` 强制刷新页面，或清除浏览器缓存后重试。

**2. 查看前端控制台（快速定位接口）**

打开浏览器开发者工具（F12 或 Ctrl+Shift+I）：

- **Network（网络）面板**：
  - 找到标红的请求（状态码 500），查看请求的 **URL、参数、请求方式（GET/POST 等）**。
  - 切换到 **Response（响应）或 Preview（预览）** 标签，看服务器是否返回了错误详情（如错误堆栈、提示信息）。
    - 例：可能看到 `Error: 数据库连接失败` 或 `NullPointerException` 等具体错误。
- **Console（控制台）面板**：
  - 查看是否有与 500 错误相关的前端报错（如请求被拦截、参数格式错误导致服务器处理失败）。

**3. 检查服务器日志（核心步骤）**

500 错误的具体原因必须通过**服务器日志**确认，常见日志位置：

- **后端项目日志**：
  - 如 Java 项目的 `logs/` 目录、Python 项目的日志文件、Node.js 的 `console.error` 输出等。
  - 查找与前端请求 URL 对应的后端接口日志，重点看 **报错堆栈信息**（通常包含错误类型、发生位置、具体原因）。
  - 常见原因：
    - 代码 bug（如空指针、数组越界）。
    - 数据库操作失败（连接超时、SQL 语法错误、权限不足）。
    - 外部服务调用失败（如调用第三方 API 超时）。
    - 服务器资源不足（内存溢出、磁盘满了）。
- **服务器系统日志**：
  - 如 Linux 的 `/var/log/nginx/error.log`（Nginx 反向代理时）、`/var/log/apache2/error.log`（Apache 时），查看是否有服务器层面的错误（如配置错误、权限问题）。

**4. 复现并调试接口**

- **用接口测试工具**（Postman、curl、Apifox 等）：
  - 复制前端报错的请求（URL、参数、请求头），直接发送给服务器，确认是否稳定复现 500 错误。
  - 逐步修改参数（如简化参数、去掉非必要字段），排查是否因特定参数导致服务器处理异常。
- **本地调试后端代码**：
  - 若能本地运行后端项目，用调试工具（如 IDEA 的 Debug、VS Code 的断点）逐步执行接口逻辑，观察变量值、分支走向，定位错误代码行。

**5. 排查服务器环境与配置**

- **环境差异**：确认服务器环境（如操作系统、依赖版本、数据库版本）与开发环境是否一致（例如开发时用 MySQL 8.0，服务器用 MySQL 5.7 可能存在语法兼容问题）。
- **配置文件**：检查服务器配置（如数据库连接地址 / 账号密码、API 密钥、端口占用情况）是否正确，是否存在拼写错误或权限不足。
- **资源状态**：
  - 用 `top` 或 `htop` 查看服务器 CPU、内存使用率（是否因资源耗尽导致崩溃）。
  - 用 `df -h` 检查磁盘空间（是否满了）。
  - 检查数据库是否正常运行（`systemctl status mysql` 等命令）。

**6. 总结排查思路**

1. 前端控制台定位出错的接口和参数。
2. 服务器日志找具体错误原因（核心）。
3. 用工具复现接口错误，缩小排查范围。
4. 检查代码逻辑、环境配置、服务器资源。

如果日志里有具体的错误信息（如 “找不到某某方法”“数据库连接失败”），可以针对性解决；如果是偶发 500 错误，可能需要排查并发问题或网络波动。

### 写一个得出n以内的所有质数的程序

```go
// 欧拉筛法（线性筛）
func eulerSieve(n int) []int {
	if n < 2 {
		return []int{}
	}

	isPrime := make([]bool, n+1)
	for i := range isPrime {
		isPrime[i] = true
	}
	isPrime[0], isPrime[1] = false, false

	primes := []int{}

	for i := 2; i <= n; i++ {
		if isPrime[i] {
			primes = append(primes, i)
		}
		// 用已找到的质数标记合数
		for _, p := range primes {
			if i*p > n {
				break
			}
			isPrime[i*p] = false
			if i%p == 0 { // 保证每个合数只被最小质因子标记
				break
			}
		}
	}

	return primes
}
```

### 举例说一个牺牲空间换时间的例子

**哈希表**：用复杂的结构来保证O(1)的效率；

### 为点外卖付款时使用红包的场景设计测试用例

单个红包、多个红包只能选一个、满减条件验证、品类限制验证、时间限制验证

### 优化mysql表？优化了哪些东西？

结构设计、索引优化、查询优化

### mysql优化索引的机制了解吗？

1. **联合索引顺序**：将过滤性强的字段放前面（遵循 **"最左前缀"**）；
2. **覆盖索引优先**：查询字段全部包含在索引中，避免回表；

### myisam和innodb的区别？

核心区别对比表：

| 特性           | MyISAM                          | InnoDB                             |
| -------------- | ------------------------------- | ---------------------------------- |
| **事务支持**   | **不支持事务**                  | 支持 ACID 事务（原子性、一致性等） |
| **锁机制**     | **只支持表级锁**                | 支持行级锁 + 表级锁（默认行锁）    |
| **外键约束**   | 不支持                          | 支持                               |
| **索引结构**   | 非聚簇索引（数据和索引分离）    | 聚簇索引（数据存储在主键索引中）   |
| **崩溃恢复**   | 不支持，需手动修复（myisamchk） | 支持，通过 redo log 自动恢复       |
| **全文索引**   | 支持                            | 5.6+ 版本支持                      |
| **表空间占用** | 较小（分开存储数据和索引文件）  | 较大（聚簇索引结构）               |
| **并发性能**   | **低（表锁限制）**              | 高（行锁适合高并发写操作）         |
| **适用场景**   | 读多写少、无需事务（如博客）    | 读写频繁、需事务（如电商订单）     |

### 简单说一下myisam和innodb，针对select count(*) from user,不同引擎有什么体现？

- **MyISAM**：会**直接返回预先存储的表行数**，速度极快（O (1)）。因为 MyISAM 会在表结构中维护一个计数器，记录总行数，查询时直接读取这个值，不需要扫描表。
- **InnoDB**：需要**全表扫描或遍历索引**来统计行数（O (n)），数据量大时较慢。因为 InnoDB 支持事务和行锁，同一表在不同事务中看到的行数可能不同（隔离性要求），无法维护一个全局统一的计数器，必须实际计数。

**总结**：MyISAM **计数快**但不支持事务；InnoDB 计数慢但保证事务一致性。如果需要频繁统计行数，可在 InnoDB 中通过二级索引优化（如建一个冗余的计数表）。

### select * from user where a>123 ;假设筛出来10条数据，然后我limit3。为什么会展示这三条数据？那么是如何决定是这三条数据的？

**a无索引** → LIMIT 3 取的是 **主键顺序下最先满足条件的三行**。

**a有索引** → LIMIT 3 取的是 **索引顺序下最先满足条件的三行**。

### 我有a、b、c三个的联合索引，只是where a>3 会不会命中这个索引？a>3  b>3  会不会命中索引？

a > 3：可以用到索引；

WHERE a > 3 AND b > 3：只会用到 `a`，不会用到 `(b)`。
