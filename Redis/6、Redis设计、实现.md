# Redis的设计、实现

## 数据结构和内部编码

type命令实际返回的就是当前键的数据结构类型，它们分别是：string(字符串)、hash(哈希)、list(列表)、set(集合)、zset (有序集合)，但这些只是Redis对外的数据结构。

实际上**每种数据结构都有自己底层的内部编码实现，而且是多种实现**，这样Redis会在合适的场景选择合适的内部编码。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1668158598097/d65322ec553941ba802899e1e0071d91.png)

每种数据结构都有两种以上的内部编码实现，例如list数据结构包含了linkedlist和ziplist两种内部编码。同时有些内部编码，例如ziplist，可以作为多种外部数据结构的内部实现，可以通过**object encoding命令**查询内部编码。

Redis这样设计有两个好处：

- 第一，可以改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令，例如Redis3.2提供了quicklist，结合了ziplist和linkedlist两者的优势，为列表类型提供了一种更为优秀的内部编码实现，而对外部用户来说基本感知不到。

- 第二，多种内部编码实现可以在**不同场景下发挥各自的优势**，例如ziplist比较节省内存，但是在列表（list）元素比较多的情况下，性能会有所下降，这时候Redis会根据配置选项将列表类型的内部实现转换为linkedlist。


### redisobject对象

> Redis 使用 `redisObject` 来表示其内部的各种数据类型（如字符串、列表、集合等）。

Redis存储的所有**值对象**在内部定义为redisobject结构体，内部结构如图所示。

```c
typedef struct redisObject {
    unsigned type:4;        // 数据类型（如字符串、列表等）
    unsigned encoding:4;    // 数据编码方式
    unsigned lru:24;        // 最近一次访问时间（LRU 计数）
    int refcount;           // 引用计数
    void *ptr;              // 指向实际存储数据的指针
} robj;
```

> **字段解释**
>
> 1. **`type`**
>    - 表示 Redis 数据的类型。
>    - 常见类型：
>      - `REDIS_STRING`：字符串。
>      - `REDIS_LIST`：列表。
>      - `REDIS_SET`：集合。
>      - `REDIS_ZSET`：有序集合。
>      - `REDIS_HASH`：哈希表。
> 2. **`encoding`**
>    - 数据的实际存储编码方式。
>    - 示例：
>      - 对于字符串：`RAW`（原始存储）、`EMBSTR`（短字符串优化）、`INT`（整数编码）。
>      - 对于列表：`ZIPLIST`（压缩列表）、`LINKEDLIST`（链表）。
>      - 对于集合：`INTSET`（整数集合）、`HT`（哈希表）。
> 3. **`lru`**
>    - 记录对象的最后访问时间，用于 LRU 内存回收策略。
>    - 存储的是一个 24 位的时间戳，表示自 Redis 启动以来的时钟周期数。
> 4. **`refcount`**
>    - 引用计数，用于实现内存管理。
>    - 如果引用计数为 0，则**表示该对象可以被释放。**
> 5. **`ptr`**
>    - 指向实际数据的指针。
>    - 例如：
>      - 如果对象是字符串类型，`ptr` 指向一个 `SDS`。
>      - 如果对象是列表类型，`ptr` 指向一个链表或压缩列表。

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1668158598097/455898bf4c9b421c9bbcaa09ff7df7f8.png" alt="image.png" style="zoom:67%;" />

Redis存储的数据都使用redisObject来封装，包括string、hash、list、set、zset在内的所有数据类型。理解redisObject对内存优化非常有帮助，下面针对每个字段做详细说明。

#### type字段

type字段：表示当前对象使用的数据类型，Redis主要支持5种数据类型：string,、hash、list、set、zset。可以使用type {key}命令查看对象所属类型，type命令返回的是值对象类型，键都是string类型。

#### encoding字段

encoding 字段：表示Redis内部编码类型，encoding在Redis内部使用，代表当前对象内部采用哪种数据结构实现。理解Redis内部编码方式对于优化内存非常重要，同一个对象采用不同的编码实现，内存占用存在明显差异。

#### lru字段

lru字段：记录对象**最后次被访问的时间**，当配置了maxmemory和maxmemory-policy=volatile-lru或allkeys-lru时，用于辅助LRU算法删除键数据。可以使用`object idletime {key}`命令在不更新lru字段情况下查看**当前键的空闲时间。**

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1668158598097/06878d251efb42fb95c55ea847c28cfe.png" alt="image.png" style="zoom: 67%;" />

可以使用`scan + object idletime`命令批量查询哪些键长时间未被访问，找出长时间没被访问的键进行清理，可降低内存占用。

#### refcount字段

refcount字段：记录**当前对象被引用的次数**，用于通过引用次数回收内存，当**refcount=0**时，可以**安全回收**当前对象空间。使用    `object refcount {key}`命令获取当前对象引用。当对象为整数且范围在[0-9999]时，Redis可以使用**共享对象的方式**来节省内存。

> PS面试题，Redis的对象垃圾回收算法-----引用计数法。
>

#### *ptr字段

*ptr字段：与对象的数据内容相关，**如果是整数，直接存储数据，否则表示指向数据的指针。**

在Redis的新版本中，对于短字符串，即长度 <= 44字节的数据，`EMBSTR` 编码将**字符串sds（Simple Dynamic String）和redisobject一起分配在连续的内存块中。**从而只要一次内存操作即可。

> 在 Redis 的新版本中（从 3.2 开始），对字符串的存储优化主要体现在短字符串（长度小于等于 44 字节）的存储方式上。通过 **`sds` 和 `redisObject` 的内联分配**，减少了内存分配次数，从而提高了性能。
>
> **传统存储方式**
>
> - 以前，`redisObject` 和 `SDS` 是独立分配的：
>   - `redisObject` 存储元信息。
>   - `ptr` 字段指向单独分配的 SDS 数据。
> - 这需要两次内存分配操作。

> PS：高并发写入场景中，在条件允许的情况下，建议字符串长度控制在44**字节以内，减少创建redisobject**内存分配次数，从而提高性能。
>

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1668158598097/de771c3770b242be8ca619252dd10c94.png)

## Redis中的线程和IO模型

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1668158598097/f7d5d5855fa2494e96154534adcb6acc.png" alt="image.png" style="zoom: 80%;" />

Redis 基于 Reactor 模式开发了自己的**网络事件处理器 - 文件事件处理器（file event handler，后文简称为 FEH）**，而该处理器又是单线程的，所以**redis设计为单线程模型。**采用I/O多路复用**同时监听多个socket**，根据socket当前执行的事件来为socket选择对应的事件处理器。当被监听的socket准备好执行**accept、read、write、close**等操作时，**和操作对应的文件事件**就会产生，这时FEH就会调用socket之前关联好的**事件处理器**来处理对应事件。

所以虽然FEH是单线程运行，但通过I/O多路复用监听多个socket，不仅实现高性能的网络通信模型，又能和 Redis 服务器中其它同样单线程运行的模块交互，保证了Redis内部单线程模型的简洁设计。

下面来看文件事件处理器的几个组成部分。

#### socket

文件事件就是对socket操作的抽象， 每当一个 socket 准备好执行连接accept、read、write、close等操作时， 就会**产生一个文件事件**。一个服务器通常会连接多个socket，多个socket可能**并发产生不同操作**，**每个操作对应不同文件事件。**

#### I/O多路复用程序

I/O 多路复用程序会负责监听多个socket。

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1668158598097/cdb769bb4c7649e0acd1bad68b4c0662.png" alt="image.png" style="zoom:80%;" />

#### 文件事件分派器

文件事件分派器接收 I/O 多路复用程序传来的socket， 并根据socket产生的事件类型， **调用相应的事件处理器。**

#### 文件事件处理器

服务器会为执行不同任务的套接字关联不同的事件处理器， **这些处理器是一个个函数**， 它们定义了某个事件发生时， 服务器应该执行的动作。

Redis 为各种文件事件需求编写了多个处理器，若客户端连接Redis。

- 对连接服务器的各个客户端进行应答，就需要将socket映射到连接应答处理器，然后写数据到Redis。

- 接收客户端传来的命令请求，就需要映射到命令请求处理器，从Redis读数据
- 向客户端返回命令的执行结果，就需要映射到命令回复处理器。
- 当主服务器和从服务器进行复制操作时，主从服务器都需要映射到特别为复制功能编写的复制处理器。

### Redis6中的多线程

#### **Redis6.0之前的版本真的是单线程吗？**

Redis在处理客户端的请求时，包括获取（socket读）、解析、执行、内容返回（socket写）等都由一个**顺序串行的主线程**处理，这就是所谓的**“单线程”**。但如果严格来讲从Redis4.0之后并不是单线程，除了主线程外，它也有**后台线程**在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大key的删除等等。

#### **Redis6.0之前为什么一直不使用多线程？**

官方曾做过类似问题的回复：使用Redis时，几乎不存在CPU成为瓶颈的情况。**Redis主要受限于内存和网络**。例如在一个普通的Linux系统上，Redis通过使用pipelining每秒可以处理100万个请求，所以如果应用程序主要使用O(N)或O(log(N))的命令，它几乎不会占用太多CPU。

使用了单线程后，**可维护性高**。多线程模型虽然在某些方面表现优异，但是它却引入了**程序执行顺序的不确定性**，带来了并发读写的一系列问题，增加了系统复杂度，同时可能存在线程切换、甚至加锁、解锁、死锁造成的性能损耗。Redis通过AE事件模型以及IO多路复用等技术，处理性能非常高，因此**没有必要使用多线程**。单线程机制使得 Redis 内部实现的复杂度大大降低，Hash的惰性Rehash、Lpush等等“线程不安全” 的命令都可以无锁进行。

#### **Redis6.0为什么要引入多线程呢？**

Redis将**所有数据放在内存**中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理80,000~100,000 QPS，这也是Redis处理的极限了，**对于80%的公司来说，单线程的Redis已经足够使用了。**

但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点：

- 例如要管理的Redis服务器太多，维护代价大；

- 某些适用于单个Redis服务器的命令不适用于数据分区；

- **数据分区无法解决热点读/写问题**；

- 数据偏斜，重新分配和放大/缩小变得更加复杂等等。

> **数据分区**（Data Partitioning），也称为**数据分片**，是指将数据划分成多个小块或分片（Partitions），并将这些分片分布到不同的存储单元（如节点、服务器或数据库实例）上的一种策略。

所以总结起来，redis支持多线程主要就是两个原因：

- 可以充分利用服务器 CPU 资源，目前主线程只能利用一个核。


- 多线程任务可以分摊 Redis 同步 IO 读写负荷。


#### Redis6.0默认是否开启了多线程？

Redis6.0的多线程**默认是禁用**的，只使用主线程。如需开启需要修改redis.conf配置文件：`io-threads-do-reads yes`

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1668158598097/fe03fc71ee284640b3de6f6f54fb521b.png)

开启多线程后，还需要设置线程数，否则是不生效的。同样修改redis.conf配置文件。

关于线程数的设置，官方有一个建议：4核的机器建议设置为2或3个线程，8核的建议设置为6个线程，**线程数一定要小于机器核数**。还需要注意的是，线程数并不是越大越好，官方认为超过了8个基本就没什么意义了。

#### **Redis6.0采用多线程后，性能的提升效果如何？**

Redis 作者 antirez 在 RedisConf 2019分享时曾提到：Redis6引入的多线程 IO 特性**对性能提升至少是一倍以上**。国内也有大牛曾使用unstable版本在阿里云esc进行过测试，GET/SET 命令在4线程IO时性能相比单线程几乎是翻倍了。如果开启多线程，至少要4核的机器，且**Redis实例已经占用相当大的CPU耗时的时候才建议采用**，否则使用多线程没有意义。

## 缓存淘汰算法

当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)。交换会让 Redis 的性能急剧下降，对于访问量比较频繁的 Redis 来说，这样龟速的存取效率基本上等于不可用。

**maxmemory-policy参数**

在生产环境中我们是**不允许 Redis 出现交换行为**的，为了**限制最大使用内存**，Redis 提供了配置参数`maxmemory`来限制内存超出期望大小。当实际内存超出 maxmemory 时，Redis 提供了几种可选策略（maxmemory-policy）来让用户自己决定该如何腾出新的空间以继续提供读写服务。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1668158598097/f2ae13d3e120402fa571cf23230820b0.png)

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1668158598097/c8b26778022d4f2487207d79048b6934.png" alt="image.png" style="zoom: 67%;" />

> policy：策略

### Noeviction

noeviction**不会继续服务写请求**。但是DEL请求可以继续服务，读请求也可以继续进行。这样**可以保证不会丢失数据**，但是会让线上的业务不能持续进行。这是**默认的淘汰策略。**

### volatile-lru

volatile-lru 尝试淘汰**设置了过期时间**的key，**最近最少使用**的 key 优先被淘汰。没有设置过期时间的 key 不会被淘汰，这样可以保证需要持久化的数据不会突然丢失。

### volatile-ttl

volatile-ttl 跟上面一样只对**设置了过期时间的键**生效，除了淘汰的策略不是 LRU，而是 key 的剩余寿命 ttl 的值，**ttl 越小越优先被淘汰。**

### volatile-random

volatile-random 跟上面一样只对**设置了过期时间的键**生效，不过淘汰的key是**（设置了）过期key集合中的随机key。**

### allkeys-lru

allkeys-lru 淘汰最近最少使用的键，区别于volatile-lru，这个策略要淘汰的key对象是**全体的 key 集合**，而不只是过期的key集合。这意味着没有设置过期时间的 key 也会被淘汰。

### allkeys-random

allkeys-random 随机淘汰任意一个键。

volatile-xxx 策略只会针对带过期时间的key 进行淘汰，allkeys-xxx 策略会对所有的 key 进行淘汰。

- 如果你只是拿 Redis 做缓存，那应该使用 allkeys-xxx，客户端写缓存时不必携带过期时间。

- 如果你还想同时使用 Redis 的持久化功能，那就使用 volatile-xxx 策略，这样可以保留没有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法淘汰。

### LRU 算法

实现 LRU 算法除了需要**key-value字典**外，还需要附加一个**链表**，链表中的元素按照一定的顺序进行排列。**当空间满的时候，会踢掉链表尾部的元素**。当字典的某个元素被访问时，它在链表中的位置会被移动到表头。所以链表的元素排列顺序就是元素最近被访问的时间顺序。位于链表尾部的元素就是不被重用的元素，所以会被踢掉。位于表头的元素就是最近刚刚被人用过的元素，所以暂时不会被踢。

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1668158598097/868550019206432ab181766cce12a2ce.png" alt="image.png" style="zoom:80%;" />

### 近似 LRU 算法

Redis 使用的是一种**近似 LRU 算法**，它跟 LRU 算法还不太一样。之所以不使用 LRU 算法，是因为需要消耗大量的额外的内存，需要对现有的数据结构进行较大的改造。近似LRU 算法则很简单，在现有数据结构的基础上使用**随机采样法**来淘汰元素，能达到和 LRU 算法非常近似的效果。Redis为了实现近似 LRU 算法，它给**每个 key 增加了一个额外的小字段**，这个字段的长度是24个bit，也就是**最后一次被访问的时间戳。**

当 Redis 执行**写操作**时，发现内存超出maxmemory，就会执行一次 LRU 淘汰算法。这个算法也很简单，就是**随机采样**出5（可以配置maxmemory-samples）个 key，然后**淘汰掉最旧的key**，如果淘汰后内存还是超出maxmemory，那就继续随机采样淘汰，直到内存低于 maxmemory 为止。

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1668158598097/8376f180d4aa43b5b7319a6a4d4f721e.png" alt="image.png" style="zoom: 67%;" />

如何采样就是看 maxmemory-policy 的配置，如果是 allkeys 就是从所有的 key 字典中随机，如果是 volatile 就从带过期时间的 key 字典中随机。每次采样多少个 key 看的是 maxmemory_samples 的配置，**默认为 5。**

**采样数量越大，近似 LRU 算法的效果越接近严格LRU 算法。**

同时 Redis3.0 在算法中增加了**淘汰池**，新算法会维护一个候选池（大小为16），池中的数据根据访问时间进行排序，第一次随机选取的key都会放入池中，随后每次随机选取的key只有在访问时间小于池中最小的时间才会放入池中（也就是时间更久远），直到候选池被放满。当放满后，如果有新的key需要放入，则将池中最后访问时间最大（最近被访问）的移除。进一步提升了近似 LRU 算法的效果。

Redis维护了一个**24位时钟**，称为系统时钟或全局时钟，可以简单理解为**当前系统的时间戳**，每隔一定时间会更新这个时钟。每个key对象内部同样维护了一个24位的时钟，称为内部对象时钟（也就是键的时钟）。当新增key对象的时候会把**系统时钟赋值到这个内部对象时钟**。比如我现在要进行LRU，那么首先拿到当前的全局时钟，然后再找到内部时钟与全局时钟距离时间最久的（差最大）进行淘汰，这里值得注意的是全局时钟只有24位，按秒为单位来表示只能存储194天（换句话说，Redis 的全局时钟会在 **每 194 天后循环回到 0**），所以可能会出现key的时钟大于全局时钟的情况，如果这种情况出现那么就两个**相加**而不是相减来求最久的key。

### LFU算法

LFU算法是Redis4.0里面新加的一种淘汰策略。它的全称是**Least Frequently Used（最近不经常使用）**，即**最少使用频率**，它的核心思想是根据key的最近被访问的频率进行淘汰，**很少被访问的优先被淘汰**，被访问的多的则被留下来。

> LRU和LFU对比：
>
> - LRU 算法同构维护一个按**访问时间**排序的结构（例如链表或栈）来实现，以未被使用的时间长短作为淘汰依据。
>
> - LFU 算法则是为每个数据项维护一个 **访问计数器**，访问频率最低的数据将会被淘汰，以访问频率作为淘汰依据。

LFU算法能更好的表示一个**key被访问的热度**。假如你使用的是LRU算法，一个key很久没有被访问到，只刚刚是偶尔被访问了一次，那么它就被认为是热点数据，不会被淘汰。而有些key将来是很有可能被访问到的则被淘汰了。如果使用LFU算法则不会出现这种情况，因为使用一次并不会使一个key成为热点数据。LFU原理是**使用计数器来对key进行排序**，每次key被访问的时候计数器会增加。计数器值越大，可以约等于访问越频繁。具有相同引用计数的数据块则按照时间排序。

**LFU一共有两种策略：**

- **volatile-lfu**：在设置了过期时间的key中使用LFU算法淘汰key。
- **allkeys-lfu**：在所有的key中使用LFU算法淘汰数据。

LFU把原来的**key对象的内部时钟**的24位**分成两部分**，前16位ldt(Last Decrement Time)还代表时钟，后8位logc(Logistic Counter)代表一个计数器。

![lru_24 bit.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cfa97cd64d44fb89cf4e7b7fb379415~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

> **ldt字段** 是 Redis 在内部淘汰逻辑中用于标记某些键的最后处理时间。它只在 **Redis 的内存淘汰逻辑执行时** 更新，而不是每次访问对象时更新。淘汰逻辑触发的前提是：
>
> 1. Redis 总内存占用达到了 `maxmemory` 的限制。
> 2. 在 Redis 每次执行指令之前，检查是否需要进行淘汰操作。
>
> **基于淘汰策略的具体行为**：
>
> - 在内存淘汰策略（如LFU）的实现过程中，只有那些被 Redis 判断为“需要淘汰”或“需要检查”的 key 的 `ldt` 字段会被访问和更新。
> - **非被检查或淘汰的 key 的 `ldt` 不会被更新**。

- 高16bit的ldt字段用来**存储最近一次计数器降低的时间**，也就是说ldt更新的同时也会一同衰减logc的值。因为只有16个bit，所精度不可能很高，它可以表示的最大值为65535（2^16-1）。它取的是**分钟时间戳对2^16进行取模。**大概45.5天（65535/24/60）会折返（折返指的是取模后的值重新从0开始）。
- 低8bit的logc字段用来**存储访问次数的对数值**，由于只有8bit，它可以表示的最大值为255。实际上，logc无法记录真实的Redis key的访问次数。logc每次key被访问时都会更新，并且**这个值还会随衰变周期衰减**，如果它的值比较小，那么就很容易被回收。为了确保新创建的对象不被回收，新对象的这8个bit会被初始化为一个大于零的值**LFU INIT_VAL（默认是=5）。**

ldt的值和LRU模式的lru字段不一样的地方是，ldt不是在对象每次被访问时更新的，而是在Redis进行淘汰逻辑时更新，**淘汰逻辑只会在内存达到maxmemory的设置时才会触发**。

每个指令执行前都将触发**随机淘汰策略**，**随机挑选**若干个 key，对每个key的logc做衰减，即更新这个key的“热度”。大致就是需要得到该对象(key)上次的ldt时间到当前时间之间的分钟差（根据是否回绕，有不同的计算）。得到这个数字后，除以一个衰减系数lfu_decay_time（默认为1，如果该值为0，就是不衰减的意思，如果该值大于1，那么衰减的速度就会比较慢，该值可以进行配置），最后使用key的logc减去这个值，算出最终衰减后的数量。

如果一个key的logc一直没有更新，也就是很久没被访问时，或者更新的不是很频繁，那么势必会慢慢变得很小，所以最后发生淘汰时，使用时间做出衰减的时候，其值会被衰减的很小甚至可能为0，那么大概率就要被淘汰掉了。

**淘汰掉logc最小也就是“热度”最低的key**。

因为Redis采用的是随机算法，如果key比较多的话，那么ldt更新得可能会比较慢。不过既然它是分钟级别的精度，也没有必要更新得过于频繁。

>  注意：**lru 字段** 是一个存储在每个对象元数据中的时间戳，用于记录最近一次访问的时间。

![image-20250605203623358](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250605203623358.png)

### 为什么 Redis 要缓存系统时间戳

我们平时使用系统时间戳时，常常是不假思索地使用System.currentTimeInMillis或者time.time()来获取系统的毫秒时间戳。**Redis不能这样**。因为每一次获取系统时间戳都是一次**系统调用**，系统调用相对来说是**比较费时间**的，作为单线程的Redis承受不起，所以它需要**对时间进行缓存**，由一个定时任务，每毫秒更新一次时间缓存，**获取时间都是从缓存中直接拿。**

## 过期策略和惰性删除

### 过期

Redis 所有的数据结构都可以设置过期时间，时间一到，就会自动删除。但是会不会因为同一时间太多的key过期，以至于忙不过来。同时因为Redis 是单线程的，删除key的时间也会占用线程的处理时间，如果删除的太过于繁忙，会不会导致线上读写指令出现卡顿。

**过期的 key 集合**

redis 会将每个设置了过期时间的key放入到一个**独立的字典**中，以后会**定时遍历**这个字典来删除到期的key。除了定时遍历之外，它还会使用**惰性策略**来删除过期的key，所谓惰性策略就是在客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除。**定时删除是集中处理，惰性删除是零散处理。**

**定时扫描策略**

Redis默认会**每秒进行十次过期扫描**，过期扫描**不会遍历**过期字典中所有的 key，而是采用了一种简单的**贪心策略。**

1. 从过期字典中随机 20 个 key；

2. 删除这 20 个 key 中已经过期的 key；

3. 如果过期的 key 比率超过 1/4，那就重复步骤 1。

设想一个大型的 Redis 实例中所有的 key 在同一时间过期了，会出现怎样的结果？

毫无疑问，Redis 会持续扫描过期字典 (循环多次)，直到过期字典中过期的 key 变得稀疏，才会停止 (循环次数明显下降)。这就会导致线上读写请求出现明显的卡顿现象。导致这种卡顿的另外一种原因是内存管理器需要**频繁回收内存页**，这也会产生一定的 CPU 消耗。所以业务开发人员一定要注意过期时间，如果有大批量的 key 过期，要给过期时间设置一个**随机范围**，而不能全部在同一时间过期。

**从库的过期策略**

从库不会进行过期扫描，**从库对过期的处理是被动的**。主库在 key 到期时，会在AOF文件里增加一条 **del 指令**，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。因为指令同步是异步进行的，所以主库过期的 key 的 del 指令没有及时同步到从库的话，会出现主从数据的不一致，主库没有的数据在从库里还存在，比如前一节的集群环境分布式锁的算法漏洞就是因为这个同步延迟产生的。

### 惰性删除

所谓惰性策略就是在客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。

定期删除可能会导致很多过期key到了时间并没有被删除掉，所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，即当你主动去查过期的key时，如果发现key过期了，就立即进行删除，不返回任何东西。

**总结：定期删除是集中处理，惰性删除是零散处理。**

### lazyfree（惰性删除）

> 在redis中，flushdb和flushall 都是清空当前数据库的操作，但是两者有很大的区别：
>
> 1. flushall 清空数据库并执行持久化操作，也就是rdb文件会发生改变，**连着rdb文件也被清空了**，变成76个字节大小（初始状态下为76字节），所以执行flushall之后数据库真正意义上清空了。
>
>
> 2. flushdb 清空数据库，但是不执行持久化操作，也就是说rdb文件不发生改变。而redis的数据是从rdb快照文件中读取加载到内存中的，所以在flushdb之后，**如果想恢复数据库，则可以直接kill掉redis-server进程**，然后重新启动服务，这样redis重新读取rdb文件，数据就可以恢复到flushdb操作之前的状态了。
>
>    注意：要直接kill 掉redis-server服务，如果直接shutdown会触发持久化，导致无法恢复。使用lsof -i:6379 命令查看redis-server的进程号，然后kill即可。

使用 DEL 命令删除体积较大的键，又或者在使用FLUSHDB 和 FLUSHALL删除包含大量键的数据库时，易造成redis阻塞的情况。另外redis在清理过期数据和淘汰内存超限的数据时，如果碰巧撞到了大体积的键也会造成服务器阻塞。为了解决以上问题， redis 4.0 引入了lazyfree的机制，它可以将删除键或数据库的操作**放在后台线程里执行**，从而尽可能地避免服务器阻塞。

lazyfree的原理不难想象，就是在删除对象时只是进行逻辑删除，然后把**对象丢给后台**，让**后台线程去执行真正的destruct**，避免由于对象体积过大而造成阻塞。

redis的lazyfree实现即是如此，下面我们由几个命令来介绍下lazyfree的实现。4.0 版本引入了 **unlink 指令**，它能对删除操作进行**懒处理**，丢给后台线程来**异步回收内存**。

UNLINK 的实现中：①首先会清除过期时间；②然后调用`dictUnlink`把要删除的对象**从数据库字典摘除**；③再判断一下对象的大小（太小就没必要后台删除），如果足够大就丢给后台线程；④最后清理下数据库字典的条目信息。

主线程将对象的引用从「大树」中摘除后，会将这个 key 的**内存回收操作**包装成一个任务，塞进**异步任务队列**，后台线程会从这个异步队列中取任务。任务队列被主线程和异步线程同时操作，所以必须是一个**线程安全**的队列。

Redis 提供了 flushdb 和 flushall 指令，用来清空数据库，这也是极其缓慢的操作。Redis 4.0 同样给这两个指令也带来了异步化，在指令后面增加 **async 参数**就会进入**后台删除逻辑。**

Redis4.0 为下面这些删除点也带来了异步删除机制，打开这些点需要额外的配置选项。懒惰删除（Lazy Deletion）相关配置项如下：

1. **slave-lazy-flush**：从库接受完 rdb 文件后的 flush 操作。当从节点加载主节点数据时，是否懒惰地释放旧数据。**`no`**（默认，不使用懒惰删除）。
2. **lazyfree-lazy-eviction**：内存达到 maxmemory 时进行淘汰，在内存淘汰策略（Eviction）下，是否懒惰删除被淘汰的键。
3. **lazyfree-lazy-expire**：key 过期删除。在键过期（Expire）时，是否懒惰删除过期的键。**`no`**（不使用懒惰删除）。过期键被访问时，立即删除。启用后（`yes`），过期的键将被懒惰删除，而不是立即删除。
4. **lazyfree-lazy-server-del**：rename 指令删除 destKey（？）。在服务层删除键（例如通过 `DEL` 命令、清空数据库等操作）时，是否使用懒惰删除。

<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1668158598097/7a5ee80319354c2192e5147e49ed8838.png" alt="image.png" style="zoom:80%;" />

