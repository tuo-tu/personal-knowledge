今日所学内容：
总结：
遇到的问题：
是否解决：
建议：
用时大概多久：


20231130
今日所学内容：
shell编程前9节
总结：
1.shell的解析器主要是bash
2.脚本以#!/bin/bash开头，执行脚本bash+文件路径
3*.永久环境变量（写到配置文件中）：作用域是整个用户；
   临时用户环境变量（命令的方式）：作用于当前bash及其子bash；
   自定义普通变量的作用域：仅仅作用于当前bash。
4.$n、$#、$* 、$@、$？用法
5.运算符及条件判断，多条件判断&&、II用法
6.流程控制：$*和$@区别
7.read读取控制台输入操作
8.系统函数与自定义函数基本用法
遇到的问题：
是否解决：
建议：
用时大概多久：4小时

20231201
今日所学内容：
shell脚本编程：
1.函数案例和cut命令、
2.cut、awk、sed、sort命令
计算机网络概述：
1.计算机网络在信息时代中的作用；
2.因特网发展的三个阶段；
3.因特网的组成：功能划分、边缘部分、核心部分；
4.计算机网络的分类：按照网络的作用范围进行分类；按网络的线路结构进行分类；
总结（要点）：
1.函数返回值通过$?系统变量获得，用echo命令打印，return得到的是执行状态；
2*.cut、awk、sed、sort命令用法，注意选项参数的位置及默认输出
3.internet（互联网） 和 Internet（因特网）的区别在于协议；
4.ISP的不同层次：主干ISP、地区ISP和本地ISP
5.因特网：
     边缘部分：C/S 方式、P2P 方式
     核心部分：三种交换方式（电路交换、分组交换、报文交换
6.计算机网络的分类：按照作用范围、线路结构
     按照作用范围：广域网WAN、城域网MAN、局域网LAN、个人区域网PAN
     按照线路结构：星型*、总线型、环型、网状型*
遇到的问题：
awk命令$1,$2变量的问题
是否解决：是
建议：
用时大概多久：4h

20231202
今日所学内容：
1、计算机网络的性能指标
总结：
1、数据量单位KB（k代表2的10次方，1024；B代表Byte），数据率单位bps（k代表1000，b代表bit）；带宽的单位是b/s (kbs, Mb/s, Gb/s, Tb/s)好像跟数据率单位是一样的。
2、带宽表示最高速率，吞吐量表示实际速率
3、发送时延取决于媒介的最低速率；发送速率：主机发出来，到路由器发出，这段过程的速率；发送时延决定总时延；往返时间（RTT）不包括发送时延；
4、丢包率反应网络的拥塞情况
遇到的问题：
是否解决：
建议：
用时大概多久：1.5h

20231204
今日所学内容：
计算机网络体系结构13~24小节
总结：
1、五层结构用于教学
2、协议：具有某种固定格式、双方必须遵守
3、数据在应用层进行封装、运输层加上头部，网络层加上IP协议的头部，链路层封装成帧，帧就是一组数据
4、数据链路层的3基本问题：封装成帧、透明传输、差错检验
5、最大传送单元MTU（一般是1500字节）；
6、802.3局域网简称以太网；
7、全双工模式用一对双绞线实现
8、MAC地址固化在网卡或者是适配器的ROM里面
9、MAC地址在很多时候表示网络接口，是对网络上各接口的唯一标识
遇到的问题：
0比特填充法只针对帧的数据部分进行填充吗
校验码在传输过程中有没有可能也会出错？
是否解决：解决
建议：
用时大概多久：4.5h

20231205
今日所学内容：
1、网络层1~3节
总结：
1、网络层，每朵云内部的计算机之间通信，不需要实现网络层，只需要实现物理层和数据链路层；异构网络间的通信必须要接到路由器上。
2、IP地址根据网络号字节数不同可分为5类；
3、网络地址：网络号+主机号全“0”的地址；网络号127作为本地还回测试地址，不指派；根据地址左起第一个十进制数的值，可以判断出网络类别(小于127的为A类，128~191的为B类，192~223的为C类)；网关地址不能分配给主机；
4、IP地址和子网掩码&得到IP地址的网络地址；不为0的部分是网络号，为0的是主机号（用来作标识）
遇到的问题：
1、网络号与网络地址是一样的吗？
2、网络号=&运算结果，而不只是主机号前面的部分？
是否解决：提问中，待回答
建议：
用时大概多久：2h

今日所学内容：
1、子网的划分
2、IP协议概述
3*、IP数据报的发送和转发过程
4、路由表概述
总结：
1、俩主机通信，需要将接收方的IP地址与发送方的子网掩码相&；
2、默认网关，用于找路由器，理解为就是路由器的IP地址，
3、路由器中的目的地址是指IP地址，路由器处理的是网络层中的数据
4、重点掌握IP数据报的发送和转发过程（需复习）
遇到的问题：
不可靠无连接的数据报传输服务是什么意思？
路由器路由表中子网掩码的来源是什么？网络是将与路由器所连的网络全部添加进去吗？；路由器各接口的掩码是否一样？（不一样）；目的地址与路由器左右接口的掩码都要&一遍？（收藏的问题可回答）
是否解决：
建议：
用时大概多久：4h

今日所学内容：
网络层：
   1、路由表的类型
   2、路由表实验
   3、特殊IP地址
运输层：
   1、运输层概述
   2、端口号
   3、TCP协议的首部；TCP连接的建立
总结：
1、gw：get网关
2*、ARP欺骗两种类型
3、整个127网段都不能用；路由器可以很好地隔离广播域；DHCP可以自动获取IP地址，绝大多数时间都是路由器自动给计算机分配IP地址;DNS(域名解析服务系统)
4*、TCP头部信息：重点掌握seq、ACK、ack、SYN；重点掌握三次握手过程
5、SYN的两层含义：客户端请求连接，服务器同步数据包；ACK、ack都代表确认
6、同步已发送/请求已发送，同步已接收/确认已接收
遇到的问题：
1、no shutdown 命令的作用？
2、路由表中是否会出现一对多的情况，即路由表中一个目的网路对应多个下一跳？已解决
3、直接交付的细节：既然处于同一个网络之内，那么两台主机进行数据的直接交付，是需要知道对方的MAC地址还是IP地址，或者说MAC地址还是IP地址的优先级更高？
4、同一网络中的主机之间的数据传输，是根据IP地址还是MAC地址？
5、针对回复的提问，已记录，待解答
8、组播（多播）是什么意思？
6、关于FIN标志：A发数据给B，当关闭连接是，是谁发给谁？
7、服务器何时进入监听状态（收到客户端的连接请求之后吗）？
8、如何从字面意思通俗理解同步已发送和同步已接收？同步的意思是什么？
是否解决：
建议：
用时大概多久：4h


今日所学内容：
1*、TCP可靠传输的实现（需复习）
2、用户数据报协议UDP
3、TCP和UDP的区别
4、wireshark的界面介绍
总结：
1、三次握手的时候，请求报文里面是没有实体数据的
2、三次握手的过程中，接收方就已经告知发送方自己的窗口大小
3、接收方只会累计应答最大的连续的数据包
4、浏览器向DNS服务器发送域名解析用的是UDP
5、视频会议如果用单播，将会大量占用带宽
6、长连接多用于操作频繁，点对点的通讯；短连接多用于操作不频繁，点对点的通讯
遇到的问题：
连接释放半双工问题？
流量控制是在请求连接确认阶段发送的吗
无连接是指不需要建立连接吗
是否解决：
建议：
用时大概多久：3h


今日所学内容：
1、wireshark过滤器
2、使用wireshark分析TCP三次握手
3、使用wireshark分析TCP数据包
4、万维网
5、HTTP协议
6、笔试题讲解复习
总结：
1、URL(统一资源定位器)、URI(统一资源标识符)，URL是URI的一个子集；http.request.uri contains .php命令比http contains username（发送的URL和服务器响应的数据中包含username都符合）范围更小；
2、万维网并非某种特殊的计算机网络，可理解为一个应用程序；
3、Cookie是一种对无状态的HTTP进行状态化的技术，使得万维网服务器能够“记住”用户；Cookie是保存在本地计算机上的
4、普通用户没必要关心重定向，对我想要的展示页面无影响
5、三次握手中，服务器同意连接才会进入同步已接收状态，SYN表示请求连接和同步
6、MSS小于MTU
遇到的问题：
是否解决：
建议：
用时大概多久：4h

今日所学内容：
Linux概述、虚拟机安装、Linux基本命令
总结：
1、redhat和Centos内核一样，centos是免费版；镜像选择最简化Mini版本
2、退出用户exit命令，#是超级管理员命令提示符，$是普通用户的，ctrl+Alt可以退出光标
3、vmnet8也是一个网络接口，属于虚拟机子网里面，VM软件安装好会有一个虚拟路由；网络配置文件ifcfg-ens33可自主设置IP
4、etc各种配置文件目录；var存放系统执行过程经常改变的文件（日志）；~代表普通用户家目录
5、可执行权限（x）对目录了来说该用户具有进入目录的权限；w代表修改目录名字、新建文件等
6、-F命令，在列出的目录后面主动加斜线
7、touch（修改文件的时间属性/创建文件）修改文件内容叫更改，修改文件其他内容叫改动，更改一定导致文件改动，改动不一定造成文件内容的修改，访问等于打开文件
8、mv，改名或移动，
9、cp，-a保留原来的属性。Tab键可自动补全
遇到的问题：
是否解决：
建议：
用时大概多久：4.5

今日所学内容：
Linux命令及vi命令
总结：
1、cat，打印文本文件，-n显示行号；more一般打印内容较多的文件；more按页输出，q退出；ps aux显示当前Linux操作系统的所有进程；head 命令默认显示前10行，tail打印尾巴，加-f可查看源源不断写进来的新数据；which 查找显示是 PATH 中的命令
2、二进制文件就是可执行文件；locate（快）是从数据库中查找，find（慢）是实时扫面整个磁盘或指定的某个目录；find命令-exec，将查出的东西做别的事情
3、tar加-f是指定压缩包（压缩成某个或者解压某个），默认压缩为tar格式，--exclude只能排除文件，不能排除目录
4、grep命令挺重要
5、ps -aux命令显示挺全；kill -9经常用到（先使用ps查找进程pro1，然后用kill杀掉）
6、 vim可以视为vi的高级版本，vim可以用颜色或者底线等方式显示一些特殊的信息。vim可以根据文件的扩展名或者是文件内的开头信息判断该文件的内容而自动调用该程序的语法判断式。（Python、shell等的语法），也就是做编程的时候才有必要使用vim。
7、末行模式：set nu显示行号；使用/word 配合 n（向下） 及N （向上）是非常有帮助的；u撤销前一次操作；2dw删除光标后两个单词；wq（w保存，q退出）；！（强制的意思）
8、:n1,n2s/word1/word2/g，s表示查找，g代表全部替换（gi表示忽略大小写），g非必须写，c表示需确认
遇到的问题：
1、cat /dev/null > text1.txt如何理解？已解决
2、less默认打印行号？默认不显示
3、find查出来的文件不一定存在？
是否解决：
建议：
用时大概多久：3.5h

今日所学内容：
1、Linux网络配置和命令
2、Linux软件安装配置
3、应用程序部署痛点、计算资源应用演进过程
总结：
1、Tab按两次给提示（列出目录下的所有文件）
2、`ONBOOT=yes`，随机器而启动；修改完配置文件ifcfg-ens33要重启网络service network restart；主机名不能用中文、不要有特殊符号、最好不要有大写（不要太特殊化），hostnamectl set-hostname mylinux1（centos7的命令）；配置host速度会变快；init 6命令也可以重启
3、DNS一般指定路由（路由器知道DNS的地址）就可以了，也可配置真实DNS服务器的地址，路径/etc/resolv.conf；Linux默认情况下防火墙只保留了22、80端口；使用Ctrl+R可以进行反向搜索历史命令
4、拍摄快照最好在关机之后，关机init 0
5、rpm搜索挺重要
6、安装软件优先从yum源中去找
7、应用部署进行容器化才能更好应用，特别是计算资源的应用以及对应用的部署；物理服务器-->虚拟机-->容器化；Docker（容器化引擎）；容器部署，各应用之间彼此隔离；容器化实际上是操作系统的虚拟化；
8、容器化，通过文件，系统可自动完成运行环境的部署，或者不需要部署（拿到的环境就是应用程序运行的环境），容器网络无需理会（容器ip地址并不固定），生成的容器模板方便分享（容器模板一般较小）；容器可控性不强，可以随着应用程序启动或停掉（因此不要试图管理容器）
遇到的问题：
是否解决：
建议：
用时大概多久：4h

今日所学内容：
总结：
1、容器就是虚拟机把操作系统这部分去掉，剩下的部分就是容器；容器既能够像虚拟机一样为应用提供良好的管理空间，又能够减少对物理机资源的浪费，容器镜像不能改（不可变），Containerd比Docker更轻量化，容器必须要有容器镜像，有镜像才能启动容器；无法像镜像里面保存文件
2、安装了Docker daemon（docker守护进程）的主机就是docker主机，实际企业应用中是把Docker daemon安装在物理机中，安装在虚拟机中是用于实验，Docker daemon是管理工具，并不生成容器；Containerd.io生成容器，提供容器服务。
3、Docker Dashboard也可以安装在Windows系统中对Linux中的容器进行操作。
4、容器当中必须有命令执行，否则容器会被停止；docker inpect 查看容器详细信息（镜像、网络状态等）；进入到容器，如果退出容器就会停止；容器要停止后才能删除
遇到的问题：
1、横向扩展就是扩缩容？
2、明明空间
3、使用容器运行nginx应用
4、交互式
5、注意哪些命令是在容器里面敲，哪些是在host上
是否解决：
建议：
用时大概多久：

今日所学内容：
1*、容器与镜像
2*、容器镜像介绍及其应用
3、容器镜像加速器及容器镜像仓库
总结：
1、容器可读写，镜像不可读写
2、docker commit命令把已经改变的overlay和已经存在的rootfs进行了一个叠加，形成一个新的镜像；docker export导出容器，但是并没有生成镜像，用此命令导出的容器不能用千万不能用load导入，只能用import导入；用的比较多的是save和load的方式；服务器都存储在镜像仓库（存储在服务器本地会消耗掉大量空间）
3、容器镜像仓库；存储镜像减少本地空间、已经生成的镜像通过容器进行更好的分发；


遇到的问题：
docker run -it centos:msb bash，这里bash是什么作用？
是否解决：
建议：
用时大概多久：2

2023/12/18
今日所学内容：
容器化部署企业级应用，内容较多
总结：
1、暴露端口的方式实际应用中并不多，因为在容器化的应用中，宿主机的端口是稀缺资源；
2、镜像当中不会包含网站内容（镜像是不可变的基础设施）
3、主节点写，从节点读的方式实现读写分离
4、--replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。
5、操作系统中文件系统进行打包：打包根文件系统；
6、构建类指令不会在生成容器的时候执行；EXPOSE声明容器运行的服务端口，是容器本身的端口，并不是端口映射；dockerfile可以写多个from
遇到的问题：
宿主机是指操作的电脑还是敲命令的那台主机？
三主三从的分配是怎么来的？
是否解决：
建议：
用时大概多久：

今日所学内容：
Docker容器网络与通信原理深度解析（未完成）
总结：
1、多条run会让镜像建立多层，变得臃肿，尽量使用&&符号与\符号连接成一行。Dockerfile中能写到一行的指令，一定要写到一行，因为每条指令都被视为一层，层多了执行效率就慢；
2、镜像是不可变的基础设施，因此每次部署都是生成新的镜像，而不是改变原来的镜像
3、安装了docker会出现一个网桥docker0（交换机）；veth虚拟的以太网设备，产生容器的过程中会自动创建，成对出现；通过Linux内核相对转发，通过外网网卡就能够实现连网；
4、docker网络模型默认是bridge [桥接式网络；host  [开放式容器模式能够让与主机同一网段的其他主机能够快速访问容器当中的服务（比较消耗主机）；overlay可以实现跨主机容器间的通信；
5、使用host类型网络，运行了一个容器以后，不能再运行一个相同的容器（无法访问它）；none模式类似于虚拟机的仅主机模式；
6、Flannel在整个通信中会使用ETCD来存储自己的节点的配置信息；
遇到的问题：
是否解决：
建议：
用时大概多久：3h

今日所学内容：
1、容器持久化存储机制
2、docker compose
3、docker swarm（未完成）
总结：
1、etcd部署为多节点；
2、ETCD在配置过程中KEY是以文件夹的方式来提供，值是以文件夹或者文件当中的内容来提供的；ETCD中保存了flannel所使用的网段
3、docker run -v和bind mounts挂载的方式比较灵活；挂载后，容器中的文件内容改变，本地也变；volums方式可自动把文件存进去；
4、微服务架构采用容器的方式实现；服务对应容器
5、docker-compose只能部署在单主机上面，docker-compose.yaml中的服务是自上而下启动
6、docker stack是docker swarm中最大的管理单位，docker swarm组织了更大的集群来实现应用的部署；
7、replicas控制器（副本控制器）持续地让任务达到用户所期望的状态，任务永远不会结束。
8、token会过期，过期后再加入工作节点要重新生成token；管理节点最好3台以上，管理节点也可以承载计算资源；
9、--publish 80:80，把服务当中的80端口映射到集群的所有主机上80端口；容器就是任务；管理节点与工作节点的关系在关于运行用户负载的过程中并不是那么严格；缩容会自动删除容器
10、删除服务可以，但是不要删除任务（任务对应的容器），replicated是副本模式，docker swarm集群会始终达到用户输入的正常期望状态（不能达到说明服务有问题），直接删除服务即可（会把容器也删除）
11、服务更新的前提是要有服务，更新/回退能给任务里面的容器同时更新，如果同时出错会造成用户的体验感不好；
12、副本控制器，维护用户所期望的任务的状态（服务的状态）
13、docker swarm默认用的是Ingress服务模式
14、管理节点才能删除服务；host模式没有指定调度到哪一台服务器，不靠谱
15、未做持久化存储，服务结束后，服务中所使用的文件也消失了
遇到的问题：
是否解决：
建议：
用时大概多久：

今日所学内容：
GO语言介绍、GO语言的内存管理、走进golang
总结：
部署NFS存储实现网络存储，在habor服务器上部署NFS服务，showmount -e验证共享目录；
1、go语言没有指针运算；&就是取地址符；GO语言只有一种传参数的方式--传值，用指针才能修改原本的值，GO的指针是只读（无法修改），GO是面向函数编程（函数是一等公民）
2、指针*&，*是声明，&是取地址；函数也可以当成变量来用；函数可以当参数传给另外一个函数；
3、GO并发，核心内容，抢java、c、c++、php市场的关键点；
4、虚拟内存page，需要的时候就装到物理内存里面，不需要挪动对象，page是用来存储的最基本的单元和跟物理内存做交换的最基本的单元，page是8k；bitmap记录gc的信息，哪些对象扫描过了，哪些对象没有扫过；GO里面对对象进行了分层分类。根据工业实践，按照对象的大小进行了分类（67种，而且是离散值），每种对应一个规则，对象按照对应规则进行分配
5、定义的变量或者import的包如果没有使用到，代码不能编译通过；ctrl+/行注释，shift+alt+a块注释；
遇到的问题：
是否解决：
建议：
用时大概多久：

今日所学内容：
总结：
1、var是变量类型声明的关键字，int默认值是0；GO语言浮点数只有float类型；没有单独的字符型，GO语言字符就是整数，使用byte来保存单个字母宇符；有符号类型可以表示正数和负数，无符号类型只能表示正数；go浮点数只有float32和float64；注意GO中字符串属于基本类型；
2、字符类型的ASCII码基本都在0-255的范围之内，所以用byte类型存储；字母，数字，标点等字符，底层是按照ASCII进行存储；汉字字符，底层对应的是Unicode码值；ASCII码是Unicode码的子集，对应前128位；golang的字符对应的字符集是ASCII码，用的是UTF-8编码方案；想显示对应的字符，必须采用格式化输出，比如Printf
3、GO中只有显式转换（强制转换）
4、函数说明问题，a ...interfacef{}指多个参数，并且支持任意类型
5、GO里面没有指针的运算；
6、"_"不能单独作为标识符；
7、尽量保持package的名字和目录保持一致，如main包；
8、% 取模等价公式:a%b=a-a/b*b；运算结果的正负，与第一个运算数(被除数)一致。
9、go语言里，++，--只能单独使用，不能参与到运算中去；++，--只能在变量的后面，不能写在变量的前面；
10、条件表达式左右的()可以不写，也建议不写；变量的定义和条件表达式可以并列写在一起；
11、default分支可以放在任意位置上，不一定非要放在最后；建议放最后；
12、GO只有for循环，for循环写法简单，但是底层效率没有提高；break后没有分号；
13、函数，为完成某一功能提取出来的语句集合；
遇到的问题：
for range，i值默认从0开始？解决
是否解决：
建议：
用时大概多久：

今日所学内容：
总结：
1、如果变量名、函数名、常量名首字母大写，则可以被其他的包访问;如果首字母小写，则只能在本包中使用  （利用首字母大写小写完成权限控制）
2、GO不支持重载（重载指函数名相同，形参列表不同的函数之间）；args参数
3、基本数据类型和数组默认都是值传递的，即进行值拷贝。在函数内修改，不会影响到原来的值。
4、GO中函数也是一种数据类型；
5、go中编译识别的时候认为myInt（别名）和int不是一种数据类型，需要进行强制转换才能赋值；
6、对函数返回值命名，返回值顺序不用对应；
7、init，变量等的初始化操作；
8、如果我们某个函数只是希望使用一次，可以考虑使用匿名函数；匿名函数是一种没有函数名的函数；
9、闭包可以保留上次引用的某个值，我们传入一次就可以反复使用了；闭包本质依旧是一个匿名函数
10、defer应用场景，比如defer后面接关掉数据库的语句；
11、内置函数不用导包；
12、长度属于数组类型的一部分；Go中数组是值传递；
遇到的问题：
1、包和文件夹的关系？已解决
2、同一个包下面的不同.go文件之间的关系，怎么运用？
3、匿名函数=不用取名字？
4、为什么数组输入要带&，赋值不用？数组即指针，获取输入要先取地址所以用&，赋值已经有了地址，直接给值即可；
是否解决：
建议：
用时大概多久：


10:00 2023/12/25
今日所学内容：
切片、映射、面向对象
总结：
1、切片是构建在数组类型之上的抽象，是对数组连续片段的引用；切片容量可动态变化
2、map就是键值对；只声明map内存是没有分配空间；map的key-value输出是无序的
3、删除map没有key不会报错；map只支持for range遍历
4、GO有全局变量、全局函数，用于支持面向对象的特性；结构体等同于类，可理解为golang是基于结构体来实现面向对象；结构体未赋值时有默认值；结构体是值类型，直接指向一个内存空间；
5、go编译器底层对t.Schoo1转化为 (*t).School
6、方法是和结构体绑定在一起的；值传递即传副本
7、如果一个类型实现了String()这个方法，那么fmt.Println默认会调用这个变量的String()进行输出（也就是不用指定方法）
8、对于方法来说，接收者为值类型，可以传入指针类型，接受者为指针类型，可以传入值类型；:=推断的方式比较方便省事
9、封装类似电视机，通过遥控器就可以访问；当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问；多重继承不建议使用，会引发混乱；注意组合模式不是继承；
10、某个结构体需要实现接口，再实现接口里面的方法（必须全部实现）
11、可以把任何一个变量赋给空接口
遇到的问题：
切片的容量？
great不是应该传接口类型吗？
是否解决：
建议：
用时大概多久：

今日所学内容：
面向对象、文件和操作、协程和管道
总结：
1、多态：传参时传接口具体的实例（这个实例是实现了这个接口的结构体），就体现多态，按照统一的接口来调用不同的实现。这时接口变量就呈现不同的形态。
2、断言就是提前不知道是什么类型，根据不同类型执行不同语句；
3、关闭文件后，文件不能用于读写；单纯靠结构体无法对文件里面的内容操作，IO可以实现对文件里面的内容进行操作（可理解为一个管子），
4、读取文件带缓冲的方式，底层默认字节长度是4096，这种方式文件的打开/关闭需要自己写；
5、bufio.NewReader将文件的一部分内容获取，放入一个缓冲区；
6、ReadFile函数内部封装了Open\Close操作
7、每个线程可以当成一个任务；单核的多线程是伪多线程；协程是一种逻辑层操作，协程类似于一个函数，在函数级别进行来来回回的调用/切换；协程依托于主线程；主死从随；
8、读写锁，适用于读多写少的情况（读不用改变数据）
9、管道的本质是队列；管道是引用类型（%v打印出的值是一个地址），必须用make初始化后才能写数据；存数不能大于容量；关闭管道不能写数据，但是可以读；
遇到的问题：
1、多态问题？
2、传入值问题？
3、上锁、解锁的时间把握问题？
4、在没有使用协程的情况下，如果管道的数据已经全部取出，那么再取就会报错。这句话的底层原因？
是否解决：
建议：
用时大概多久：

今日所学内容：
管道、网络编程、反射、Go Module、goroutine调度（进行中）
总结：
1、管道不支持普通for循环遍历（但是可以用for循环往里面写数据），管道没有索引；遍历之前要对管道进行关闭；管道默认是双向的；管道只写不读就会阻塞，只要有读就不会阻塞（与读的频率无关）；本身取数据就是阻塞的；default防止select被阻塞住（防止长时间阻塞）；case后面必须进行的是io操作；
2、多个协程工作，其中一个协程出现panic，会导致整个程序崩溃，利用refer+recover解决
3、程序员工作在应用层，只关注传输层
4、反射可以在程序运行起来以后动态获取变量的各种信息；go语言的作用域是语句级的
5、（结构体）绑定的方法的顺序按照ASCII的顺序排列的；方法的首字母必须大写才能有对应的反射的访问权限；
6、Go Module相当于Python的pip，项目放在src目录下，不能重名；go mod tidy添加缺失或者删除没有使用的 modules；每个项目都要加go fmt、go imports才会生效；
7、GO的编程理念：通过通信来共享内存，而不是共享内存来通信；channel能实现数据的通信以及信号的传递；
8、GO的3个关键：Goroutine、Channel、sync
9、在GO语言中，每个并发执行的单元称为goroutine。通常称为Go协程
10、函数在main中执行，main也是一个goroutine（主goroutine，指最外层的函数，主goroutine时间到了整体流程就结束了），哪个函数先执行取决于GO调度器本身的调度；匿名函数go func() {}();
11、sync.WaitGroup实现协同调度（多个协程之间协同工作非常常用的方案）；协程外完成Add和Wait，协程内部完成Done，wait可以多次调用；主goroutine与内部gouroutine的调度差别不大，不一定谁先执行完；每一个goroutine里面都要调用Done()；使用了原子操作包atomic可以保证并发的安全性，即累加器可以正常累加成功；
12、goroutine的并发数量受内存限制，并不是本身有上限；
13、控制并发数量panjf2000/ants比较受欢迎，实现思路都是协程池（goroutine pool）
遇到的问题：
1、反射的应用场景？
2、单元测试问题？
是否解决：
建议：
用时大概多久：

今日所学内容：
goroutine调度、Channel通信（进行中）
总结：
1、协程的方式，函数可以执行到一半，给其他函数执行（让出当前的执行权。让其他函数调度）；GO语言是抢占式协程（由调度器决定），Python是协作式的协程
2、GO语言调度的核心是让M执行G；M与P绑定后，M就可以处理P中的G；
3、P的数量默认是操作系统的核数，P在程序启动时创建
4、全局队列G越来越弱化了，能不用就不用；G执行完了并不是G整体执行完了，而是指G中的一部分代码（例如系统调用操作执行完了）
5、只要创建了M，就会有一个G0出现，某个G执行完毕后，它的执行空间会被G0霸占；
6、一个G最多可以执行10ms，超时就会被让出调度权；
7、main 函数也是运行在Goroutine中；chan没有类型限制，chan也可以作为chan类型；传递信号会用空结构体类型；channel是引用类型；
8、语句（Send语句）没有返回值，操作符（接收操作符）有返回值；
9、channel未关闭，用for range读取数据会一直阻塞（接收不到数据）；阻塞不浪费资源
10、同步channel（无缓冲）可用做信号传递，有缓冲channel适合做数据通信；
11、channel中不会淘汰旧缓存项；
12、channel无法扩容；
13、使用空结构体struct{}充当信号使用，几乎不占用任何资源；
14、使用channel控制并发数量（计数器的方式）
遇到的问题：
是否解决：
建议：
用时大概多久：

今日所学内容：
Race模式、All模式
总结：
1、将双向Channel转换为单向Channel来使用（即双向Channel赋值给单向Channel）；语义即注释语法风格；Buffer缓冲；mutex互斥；closed表示channel是否关闭（通过第二个返回值可知道结果）
2、存在等待发送者等于发送者处于一个阻塞状态；
3、select捕获/监控channel的读写操作,相当于监听；Block（阻塞）；
4、编译器内部优化会将select{}直接转化为一个阻塞操作；
5、nil channel的case，核心是动态控制channel，让其变成nil或不是nil，进而达到控制case去操作channel的目的；
6、Race模式（竞速模式）：选择最快的，停止其他未完成的（释放资源）；这种方式，多核不会变慢，单核会变慢；
7、return结束函数，对应goroutine也就结束了
遇到的问题：
是否解决：
建议：
用时大概多久：

今日所学内容：
总结：
1、Timer、Ticker与goroutine是使用channel来通信；断续器Ticker通过时间间隔进行提示；Duration持续时间（时间间隔）
2、Stop、Reset都要在定时器结束之前去操作
3、如果不需要定时器的关闭和重置操作，可以使用函数time.After
4、监视某个channel就会接收到系统信号；
5、signal.Notify不指定信号类型等于全部类型；Notify函数让signal包将输入信号转发到c
6、nil channel：没有初始化的channel
7、for select使用循环多路监听
8、Context的作用是在一组goroutine 之间传递共享的值、取消信号、deadline等（理解为在某一个goroutine执行的过程中带来的数据环境）；deadline最后期限
9、Contex接口的Done()方法的channel被关闭，无论读到什么都认为Context被取消了；凡是可以取消的上下文（被动或者主动）都应该实现canceler这个接口
遇到的问题：
是否解决：
建议：
用时大概多久：

今日所学内容：
context上下文、同步与锁
总结：
1、context上下文只是传递了需要取消的公开的信号（类似一个开关），并不是context对象使得goroutine停止了
2、定时取消是在主动取消的基础上增加了定时的功能，记录了终止时间，基础都有cancelCtx（即timerCtx包含了cancelCtx）
3、Done()采用懒惰模式，且只能采用懒惰模式，因为事先不知道有多少个goroutine要使用
4、cancel()操作流程：先处理自己的channel，再处理子context，从parent的children删除自己；
5、使用context.WithValue的方式完成值的传递，context并不是全局和局部的关系，而是向下传递的关系；
6、并不是只有goroutine才能使用context上下文；建议将context作为纯粹的上下文对象来使用，作为第一参数；context存储会话级别的数据，其他的数据不用放；context有锁，所以是并发安全的；
7、互斥锁/独占锁/排他锁；TryLock()支持非阻塞的加锁；锁的是操作，不是锁具体的资源，锁与资源并不是绑定的；
8、允许一个goroutine加锁，在另一个goroutine中解锁，只要操作的锁变量是同一个即可（谁拿到lck变量，谁就有资格加锁和解锁），但一般都是在一个代码维度加锁解锁；
9、如果其他goroutine没有通过相同的锁（1没用锁，2用了其他锁）去操作资源，那么是不受锁限制的；
10、读写锁（透明的锁，可以看见，但是进不去）；锁只阻塞在RLock或Lock这种申请锁的操作上面，与内部的操作或者goroutine都没有必然的联系
11、申请了RLock，Lock操作也进不来，RLock会阻塞Lock，但是不会阻塞其他的RLock；而Lock会阻塞RLock和Lock；
13、应该根据当前的操作选择增加RLock还是Lock；
14、锁+Map是通用型的操作，不止适用于Map类型；
15、加锁的操作是在语言层面，原子操作是在操作系统(或CPU)层面；delta偏移量；
遇到的问题：
1、parentCancelCtx是怎么来的？
2、c.done.Load()的done是什么？
是否解决：
select监听的通道，是否读的问题？
建议：
用时大概多久：


今日所学内容：
同步与锁
总结：
1、使用 atomic.Value 类型可以实现除了整型以外的其他类型的原子操作
2、配置的读取操作（加载工作）应该是一个并发安全的原子操作；
3、长链接往往需要将客户端与服务器端绑定，不是复用的；缓冲就是指临时对象；
4、once.Do()里面的函数能被保证只会执行一次；
5、sync.Cond，首先要对条件做判断，满足条件才能选择等待/通知；Signal唤醒一个是唤醒最顶层的那个；NewCond使用Locker接口作为参数了；
6、本节的同步指的是一致性，即保证两个人可以一起操作，但是有先后顺序；
7、先有原子操作（CPU层面），再有锁的概念（GO语言层面）
遇到的问题：
是否解决：
建议：
用时大概多久

今日所学内容：
同步与锁、TCP程序设计1-4节
总结：
1、goroutine、channel、WaitGroup是并发编程最常用的三要素；
2、wg := &sync.WaitGroup{}，&保证wg在多个goroutine中进行传递，指针类型可以避免复制wg；
3、并发编程中的函数返回值很难起到作用，所以用channel来进行通信；
4、目录大小指的是目录当中文件（统称）的大小；
5、统计的goroutine通过channel把当前目录的大小传递到累计的goroutine里面；
6、磁盘的大小统计用的是10进制；
7、有系统操作的代码单独拿出来封装，方便做水平的置换；获取文件信息等与文件系统相关的操作（或者系统调用等）比较容易出现程序不可控的错误，GO语言层面代码的错误是可控的；
8、接受连接：Listen和Accept（阻塞接收），发起连接：Dial；
9、IP省略，使用服务器全部的可用IP；端口省略，会使用随机端口；
10、客户端在建立连接时使用的网络类型，要与服务器监听的网络类型能够匹配，否则会被拒绝创建连接；
11、省略IP部分, 绑定可用的全部IP, 包括IPv4和IPv6；
12、GO语言中不能设置Backlog；使用独立的goroutine并发编程处理业务逻辑即可解决“listen到了但是未能及时Accept”的问题；
遇到的问题：
是否解决：
建议：
用时大概多久

今日所学内容：
连接池
总结：
1、Write写阻塞，当无法继续写时，Write会进入阻塞状态. 无法继续写,通常意味着TCP的窗口已满；
2、同一个连接的并发读或写操作是Goroutine级别并发安全的，但是无法保证顺序；
3、GOB是GO语言独有的序列化方式，Protocol Buffer是谷歌公司定义的格式（RPC数据传递最通用的方式）
4、长连接也会关闭，长连接面临半连接的问题；长连接在多次传输数据中伴随着多次心跳检测；
5、客户端与服务端在完成数据传递之后都需要断开连接；
6、接收端（读），当读取到错误io.EOF时，我们认为连接已经结束关闭。
7、很多应用场景都使用连接池技术（长连接的复用），消息队列、连接数据库等
8、空闲连接是用时间来管理的，超时会被释放；
9、conn的具体工作由Factory实现；
遇到的问题：
是否解决：
建议：
用时大概多久

今日所学内容：
粘包现象、TCP专用方法、UDP程序设计基本示例
总结：
1、TCP发送的数据是流数据，没有数据与数据之间的边界（TCP层面），所以会出现粘包现象；（UDP有数据边界，不会粘包）；粘包现象有时候需要处理，有时不需要处理
2、粘包解决方案：Header+Body方式；
3、TCP专用方法要使用net.ResolveTCPAddr得到*TCPAddr；
4、使用TCPConn的目的，是需要对TCP连接的特定属性进行配置；
5、TCPConn默认就是长连接，只要不主动关闭就一直保持连接
6、UDP是“无连接”的，服务器端不需要创建监听套接字，只需要监听地址
遇到的问题：
是否解决：
建议：
用时大概多久

今日所学内容：
UDP程序设计、网络轮询器
总结：
1、如果 ​*UDPConn​是 ​connected​,读写方法 ​Read​和 ​Write​；如果 ​*UDPConn​是 ​unconnected​,读写方法 ​ReadFromUDP​和 ​WriteToUDP；
2、UDP是非面向持久（有效）连接的（无连接不可靠），因此可以使用对等服务端和客户端；对等方式，服务端未启动，客户端仍然可以发送；谁先发送谁后启动；
3、多播编程基于UDP实现；发送端只发送一次数据；
4、224.0.2.0～238.255.255.255为用户可用的组播地址（临时组地址），全网范围内有效；
5、注意ListenMulticastUDP()函数在接收端使用；
6、组播有一个特定的组IP地址；广播不用去指定；组播体现组的概念，广播体现子网的概念；
7、广播是将消息发送到在同一广播网络上的每个主机，注意这些主机需要处于同一个子网里面；
8、广播的发送端和接收端都用ListenUDP（对等方案），不用Dial，Dial用于单播和组播；多播和广播只有UDP有；
9、UDP不保证稳定传输，数据会有丢失的情况；TCP是传输控制协议（精准控制传输过程，保证稳定连接，有ack反馈），UDP是用户数据报协议；
10、IO密集型应用程序：经常下发IO，应用程序通常会花费大量的时间等待IO操作（包括网络上数据的传输时间，磁盘文件的读写时间等），应用程序需要大量等待IO操作；计算密集型（CPU密集型）则是比如做大量的数学运算；
11、IO密集型应用程序会长时间处在一个等待状态，等待数据的来回传输，
12、网络轮询器：处理运行时（执行程序期间）、IO相关操作、需要与操作系统交互；网络I/O可以看作是流式传输，文件I/O可以看作块式传输；网络轮询器它利用了操作系统提供的 I/O 多路复用模型来提升 I/O 设备的利用率以及程序的性能。
13、文件描述符（通过建立一个连接、打开一个文件返回的）
14、系统调用syscall，IO操作，需要与操作系统交换（文件，网络属于操作系统资源），这类操作称为系统调用；
15、不仅系统调用层面会有阻塞，GO程序内部（例如channel）也会有阻塞操作；
16、阻塞I/O模型不需要额消耗资源（几乎为0）；只需要维护住谁在等待，一旦出现可用的情况，就会被系统唤醒；
17、网络的IO也可以配合select channel完成非阻塞的操作，这种方式逻辑比较完整；GO语言的非阻塞I/O不是通过FD的属性实现，而是通过外部技术实现；
18、异步I/O模型，额外发送一个处理函数给OS（写程序时传递一个参数是函数类型），避免了二次请求资源的过程；
19、多路复用I/O模型，一个进程去监听一组FD（复用这个监听进程）；
20、Go语言中对I/O多路复用做了封装，底层同样是基于OS操作系统的多路复用特性；
21、select语句是GO语言在channel层面实现的多路复用模型；
22、pollfd是文件描述符做了封装，可以轮询的FD，包含文件描述符、发生的事件（事件主要就是可读或者可写），遍历状态发生改变的文件描述符；
23、Linux系统当中，一切资源皆为文件；
24、GO的网络轮询器是epoll加上goroutine的GMP的一个结合；
遇到的问题：
是否解决：
建议：
用时大概多久

今日所学内容：
RPC、HTTP、WebSocket程序设计
总结：
1、RPC，提供过程的是server端（用来实现），使用过程的是client端；Stub（方法存根）；打包是序列化，拆包是反序列化；gRPC使用protobuf数据格式；
2、gRPC 基于 HTTP/2 通信，采用 Protocol Buffers 作数据序列化。
3、gRPC的核心目的是通信，帮助标准化、结构化消息，最终的业务逻辑和gRPC没有关系，由服务端完成；
4、Go Plugin，用于 Protocol Buffer 编译器，将PB语言转换成GO语言；
5、pb.go文件是关于消息（message）的GO语言代码的转换结果，grpc.pb.go是关于服务和远程过程的代码封装转换后的结果；转换后只有结构，没有业务逻辑，最终实现的时候需要基于这些基础代码完善业务逻辑；
6、WebSocket兼容 HTTP 协议，默认端口也是80（http）和443（https）；websocket相当于在HTTP上做了一次升级；
7、WebSocket协议标识符是 `ws`（未加密）或 `wss`（加密）
8、一次握手完成后，浏览器和服务器之间就建立好了一个WebSocket协议，就可以进行全双工通信；握手部分是http协议的请求相应；
遇到的问题：
是否解决：
建议：
用时大概多久

今日所学内容：
HTML、CSS
总结：
1、学习HTML就是学习各种各样的标签；
2、注释的快捷键是ctrl+shift+/
3、charset="utf-8"，设置页面的编码，防止乱码现象，告诉浏览器用utf-8来解析这个html文档；
4、meta标签用于设置各种属性，link引入外部资源；
5、h7之后都属于无效标签，但是浏览器也不会报错；<i><u><b>倾斜下划线加粗；
6、图片：一般高度和宽度只设置一个即可，另一个会按照比例自动适应；
7、框架集合（frameset）：和body是并列的概念，不要将框架集合放入body中
8、form表单：进行数据采集工作（采集客户端的信息）；只有放在form表单中的内容才会被收集并提交；
9、div属于块级元素，有自动换行；span属于行内元素，没有换行效果；
遇到的问题：
是否解决：
建议：

今日所学内容：
JavaScript
总结：
1、浮动不会遮挡文字；
2、用浮动要考虑是否对其他的元素有影响；
3、JavaScript是一种广泛应用于各种浏览器的页面动态处理技术；
4、script标签一点用于引入外部JS文件,就不能在中间定义内嵌式代码；script也可以放到body里面；
5、变量只声明不赋值的情况下,数据和数据类型都显示 undefined；
6、js中整数和浮点数统称为数值型数据（number类型），字符串不区分“”或者‘’；
7、js中不用声明返回值，直接return即可；
8、js通过length和索引可以直接改变数组的长度，length在js中是一个属性，不是一个方法，所以不用length()；
9、eval()函数将字符串内容解析称JS代码并运行；
10、JavaScript 中的所有事物都是对象：字符串、数值、数组、函数...
11、构造器（构造函数）都会有一个对应的原型；
12、事件：浏览器侦测到的由人触发或者浏览器本身的行为；
13、js内容改变：内部信息发生变化的同时,要失去焦点；
14、window对象的方法是全局方法，不需要将window写出来
15、document是当前浏览器所打开（解析）的文档；
16、ECHARTS：帮助我们用户更加容易地用图表展示数据的一种前端技术；
遇到的问题：
是否解决：
建议：

今日所学内容：
jQuery、MySQL
总结：
1、jQuery  可以简写 $；
2、同级子标签（有同一个上级）：nth-child(n)中的奇数从1开始；
3、toggleClass方法，原来有b，则删除,如果没有,则增加b；
4、在jQuery中,事件的名称= 原始名称去掉 on
5、 DOM对象转换为jQuery    $(DOM)；jQuery转换为DOM对象  get(0)  [0]；转换后方便调用相关方法；
6、关系=二维表；Memcached、redis的数据存在内存里面，不能断电；
7、如果sql报错，可能主键就浪费了，后续插入的主键是不连号的；
8、auto_increment、not null、default只能是列级约束；
9、delete是删除一行数据；drop删除列或者整个表；
10、先删从表，再删主表；
11、dual：伪表；
12、多行函数自动忽略null值；
13、where在分组前进行过滤的，having在分组后进行后滤；
遇到的问题：
浮点数类型，总宽度？✓
having和where的区别？✓
是否解决：
建议：

今日所学内容：
MySQL、GROM介绍、基本使用CRUD
总结：
1、自然连接优点：自动匹配所有的同名列 ,同名列只展示一次；
2、using子句基于内连接inner join，inner可以不写；
3、内连接 - on子句用得最多；
4、SQL99语法 ：筛选条件和连接条件是分开的；
5、全外连接  full outer join这个语法在mysql中不支持，在oracle中支持；
6、mysql中对集合操作支持比较弱，只支持并集操作，交集，差集不支持（oracle中支持）；
7、事务保证一系列的MySQL操作要么全部执行，要么全不执行；
8、一致性基于原子性（通过原子性来确保）；
9、持久性对数据所做的任何改变通常是保存进物理数据库，即使数据库出现故障，提交的数据也应该能够恢复；
10、在回滚和提交之前，数据库中的数据都是操作的缓存中的数据，而不是数据库的真实数据；
11、查看视图，其实就是查看视图对应的sql语句；
12、ORM典型的语法特征是不用直接编辑SQL，直接通过对象的方法即可完成数据的典型操作；
13、ORM无论怎么封装，最终都是通过SQL操作数据库；
遇到的问题：
model就是ORM中的O；
把数据当做对象去看待；
是否解决：
建议：

今日所学内容：
GORM
总结：
1、给model增加一个table方法即可实现表名自定义；
2、T不能表示NULL（不能设置）；*T可以设置为nil；
3、若表中字段可以为NULL，那么应该使用*T指针类型；若表中字段需要映射为T类型，则必须限制为NOT NULL；
4、Scanner接口负责从数据库中接收值，Valuer接口负责把model的值处理成可以被数据库保存的值；
5、链式方法的核心作用是拼凑语句、设置语句；终结方法是一条语句已经拼凑好了，需要执行，能够对数据库产生影响（增删改查等）；
6、钩子：把创建的工作都集中在钩子里面，使真正create部分的代码变得很简洁；
7、any就是空接口interface{}的别名；
8、Upsert不更新ID和created_time
9、链式方法（chainable）的顺序不影响结果，最终在终结方法（finisher）的时候形成一条终结语句；
遇到的问题：

是否解决：
建议：

今日所学内容：
GORM具体操作
总结：
1、内联条件适合明确查询条件时使用，DB.Where()适合当动态拼凑条件时使用；
2、终结方法会找到该对象上记录下来的子句；
3、默认调用连续的字句，默认是and的关系；
4、字符串，配合占位符（匿名和具名占位符）构建条件，最典型的结构，推荐。
5、*gorm.DB类型用于构建复杂的逻辑运算。应该从初始的DB对象进行构建。
6、具名占位符通过名字绑定，不需要前后关系一致；
7、迭代查询：每次仅处理一条记录，处理完成再继续拿下一条；
8、保证使用过后关闭rows结果集；
9、子查询必须使用()包裹；
10、模型更新的典型方法 Save()，对整个模型进行更新；
11、若条件更新时未指定条件，并不是更新所有，而是GORM不会更新记录，同时会返回 ​ErrMissingWhereClause​错误。
12、推荐使用map[string]any而不是struct进行更新，model具有逻辑性，而map具有纯粹的数据性；
遇到的问题：

是否解决：
建议：

今日所学内容：
GORM具体操作、redis基础数据类型
总结：
1、表达式值更新使用gorm.Expr()方法构建表达式；
2、若不存在DeleteAt字段，会执行Delete操作完成真正的删除；
3、一对多的关系中，关联子段增加在多端；多对多的关联表是自动创建；
4、删除关联，删除的是关系，并不是实体记录；

5、Set 无序的集合；Zset 有序的集合；
6、./redis-cli不加参数默认连本机的服务器；
7、尽量不使用kill -9命令；建议使用shutdown关闭，可选择保存数据；
9、set 设置的键默认是没有过期时间；
10、key只有string一种数据类型；
遇到的问题：

是否解决：
建议：

今日所学内容：
redis基础数据类型、高级数据类型
总结：
1、高级数据结构：bitmaps、HyperLogLog、GEO；
2、lrange 0 -1命令可以从左到右获取列表的所有元素；
3、blpop和brpop阻塞弹出，阻塞时间为0表示一直阻塞下去；
4、ZSET给每个元素设置一个分数( score)作为排序的依据，分数在前，元素在后；默认是升序，下标从0开始；
5、布隆过滤器只能判断“某样东西一定不存在或者可能存在”。
6、UV数据(独立访客<Unique Visitor>)
7、HyperLogLog基于概率论中伯努利试验并结合了极大似然估算方法，并做了分桶优化。HyperLogLog本质是字符串；
遇到的问题：

是否解决：
建议：

今日所学内容：
持久化、分布式锁、主从与集群
总结：
1、慢查询只统计“命令执行的“时间；slowlog-log-slower-than=0表示所有的命令都是慢查询；slowlog-log-slower-than<0表示都不会被记录；
2、Redis的“发布/订阅”是发送即忘；
3、redis没有queue，只有list；
4、redis在进行数据写入时是单线程，因此可以确定顺序；
5、bgsave创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞
6、写时复制保存的是修改后的值；
7、AOF只记录写命令，重启时再重新执行AOF文件中的命令；
8、RDB-AOF混合持久化，重写的时候，采用RDB的方式保存数据，新命令则采用AOF追加；
9、redis只有一台，本身存在不可靠的问题，因此引入多个redis，redlock；
10、slave-read-only=yes是默认配置，不论是主节点还是从节点；
11、Sentinel只做监控，不存储数据，配置要求不高；
遇到的问题：
1、ack后的消息怎么处理？删除？
2、重写会不会阻塞主线程？
3、混合模式重写的时候，恰好有新命令是追加到文件里面吗？依然采用AOF的模式进行追加；
4、阻塞的是没抢到锁的线程？？
5、主从启动的具体操作；
是否解决：
建议：

今日所学内容：
主从与集群、redis缓存问题
总结：
1、哨兵的故障率非常低；
2、redis的集群主节点数量基本不可能超过1000个；
3、ASK重定向是临时的重定向；
4、redis的设计架构里面，从节点的首要作用是作为备份（实现高可用），不是为了实现读写分离；
5、cluster集群的故障发现、转移只针对主节点，从节点不会进行处理；
6、集群里面从节点永远只能是只读，不能写入；
7、渐进式的命令scan可以解决keys命令阻塞问题；
遇到的问题：
1、集群内每个节点维护定时任务默认间隔1秒，每秒执行10次怎么算出来的？
2、缓存数据同步问题，需要复盘；
是否解决：
建议：

今日所学内容：
gin框架
总结：
1、Engine的LoadHTMLGlob方法使用通配符加载子文件夹下的模板文件；
2、get方式请求，数据直接放在URL地址后，不会显示请求体；
3、请求头中信息的格式为key:value（键值对）；
4、DefaultPostForm方法:当页面中未定义表单元素进行提交给出默认值，如果页面定义了元素但是提交没有提交数据，那么不会有默认值，会认为是没有提交数据；
5、PostFormMap方法:获取map的数据,参数需要注意：传入的是整个map（而不是具体的key）；
6、AJAX的最大的特点： 异步访问，局部刷新；
7、form上传多个文件，如果上传的文件的name的名字是相同的，那么后端的处理就要发生变化；
8、模板函数printf参照Go中的fmt.Sprintf；
遇到的问题：

是否解决：
建议：

今日所学内容：
gin框架
总结：
1、中间件适合处理一些公共的业务逻辑；
遇到的问题：
1、函数指定和函数调用的区别？
2、只有db.begin()没有commit？
是否解决：
建议：

今日所学内容：
Beego框架
总结：
1、路由：将使用某个方法请求的某个URI交由特定的方法执行的过程，给到处理函数处理，处理函数也
叫Handler
2、控制器可以看作是一组处理函数的结合；
3、控制器请求方法可以自动匹配同名动作；
4、自动路由主要针对控制器和动作（例如content/select），方法任意；该路由形式，与请求method无关；
5、路由以某个请求方法请求path，执行对应的处理器；
6、路由的命名空间（NameSpace）是将路由进行分组管理；
7、响应主体编码，JSON比XML和YAML更友好，能力更强；因此主要以JSON为准；
8、web开发中的数据验证通常是指请求数据；
遇到的问题：
1、content/select ->ContentController.Select()，content的名字是否要对应？
是否解决：
建议：


今日所学内容：
微服务结构介绍、微服务拆分原则、服务发现
总结：
1、ReadForUpdate方法代表这条语句在事物周期之内被强行锁住；
2、将各个功能模块之间的耦合从通过代码的方式进行耦合变成通过服务间通讯的方式进行耦合
3、服务注册/发现，相当于一个电话本，负责找到对应服务；
4、微服务通常根据业务逻辑进行拆分；
5、Consul客户端节点只负责将操作转发到 Server 节点上，本身不提供核心功能；客户端的主要目的与大量的外部请求进行交互，降低 Server 节点的 I/O 压力；
遇到的问题：
是否解决：
建议：

今日所学内容：
健康检查、服务间通信；
总结：
1、HTTP API列表查询需要通过查询字符串filter参数进行过滤；
2、DNS查询方式的DNS服务器只解析注册其上的服务的域名（consul变成了服务器）；
3、服务注销并不是删除服务，而是删除注册在服务中心的服务登记；
4、http健康检查，需要在服务当中增加健康检查事项，同时需要增加一个处理器来处理健康检查的路由；
5、服务发现查询服务时，DNS 方式会自动过滤状态未通过的全部服务；
6、gRPC是基于H2的；
7、旧式的API 风格将对资源的操作放在了URI当中（看起来比较混乱和复杂），新式的RESTful API风格则将操作放在了Method里面；
8、Methods中的“PUT”更新整体资源，“PATCH”更新资源的部分属性；
9、流式RPC表示数据要连续地向某一端发送；
10、变长存储省空间，但是编码效率低，定长存储编码效率高，但是空间会比较浪费；
11、API网关用来接收前端（客户端）的请求，然后将这些请求转发给后端服务；（请求转发是核心功能）
遇到的问题：
是否解决：
建议：

今日所学内容：
分布式数据一致性
总结：
1、PUT方法更新Consumer，不存在则创建；PATCH方法更新，资源不存在会更新失败；
2、删除路由会删除对应的路由和插件；API路由都有限流功能；
3、令牌桶算法能够承受范围内的突发请求
4、服务降级是站在整体服务的角度，通过部分服务的降级来保证核心服务的高效运行；
5、Span当中的数据共享、传递等采用SpanContext来完成；
6、Tracing记录单个请求的处理流程；
7、分布式事务的作用就是用于保证不同节点中的数据一致性；
8、SAGA的核心思想是先使用资源，不行再退回去；
9、TCC的冻结资源是逻辑上的锁定资源；
10、3PC比2PC多了一步CanCommit（提交检查阶段），询问参与者是否具备执行事务的条件；
遇到的问题：
postman的使用需要掌握？
host模式？
是否解决：
建议：

今日所学内容：
算法与数据结构（第一章）
总结：
1、时间复杂度指的是最差的情况；
2、时间复杂度的核心在于抽象出基本动作的数量和N是什么关系；
3、最高阶项的意义是让流程设计有了一种宏观上的评价尺度，而不会在微小问题里迷失；
4、评价算法的核心指标顺序：时间复杂度（算法流程决定）、额外空间复杂度（算法流程决定）、常数项时间（实现细节决定）；
5、如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)，即常数项个数就是O(1)；
6、满足了时间复杂度最低这个指标之后，使用最少的空间叫问题的最优解，核心是算法思想；
遇到的问题：

是否解决：
建议：

今日所学内容：
算法与数据结构
总结：
1、有序数组中找到>=num最左的位置：还有区间范围
2、二分查找的时间复杂度为log N；
3、异或运算就记成无进位相加（相异为1）；
4、a & (-a)提取出最右侧的"1"；
5、哈希表增、删、改、查的操作，可以认为时间复杂度为 O(1)；
6、有序表的key是有序的；
7、有序表，增、删、改、查都是log N的时间复杂度；
8、比较器定制有序结构的组织策略需要结合有序表；
9、递归：大事化小的思想，但是大和小问题拥有同样的结构；
10、任何递归函数都一定可以改成非递归；
11、Master公式只能用在子过程都是等规模的递归问题，并且都按比例减小；
遇到的问题：

是否解决：
建议：
今日所学内容：
算法与数据结构
总结：
1、快速排序的时间复杂度O(N * logN)，数学期望；
2、堆结构就是用数组实现的完全二叉树结构；
3、堆的大小由heapsize来管，和数组本来的原始长度没关系；
4、GO语言中特有的交换数组中两个数的方式h[i], h[j] = h[j], h[i]；
5、栈的链式实现只需要一个头指针，队列的链式实现需要头指针和尾指针；
遇到的问题：

是否解决：
建议：

今日所学内容：
算法与数据结构
总结：
1、通过递归可以找出数学规律，得出最优的解法
2、搜索二叉树中序遍历的结果一定是递增的
3、宽度优先遍历基本都是用队列来实现
4、完全二叉树：①任何节点有右无左，不符合；②任何节点一旦左右不双全，那么后续的节点必须是叶子节点；
5、平衡二叉树：任何左子树与右子树的高度差<=1
6、前缀树的字符是挂在路上的
7、range 遍历则会得到 rune 类型的字符
遇到的问题：

是否解决：
建议：

今日所学内容：
算法与数据结构
总结：
1、评估并查集的好坏，用走链的代价评估；
2、能够合成一个集合的石头群，一定可以通过方法移除到只剩一个；总能移除边缘的石头，留下一个中心；
3、 a / b 向上取整 -> (a + b - 1) / b
4、贪心算法没有固定的思想，学习主要以增加阅历和经验为主；
5、图更多时候采用邻接表表示；
6、拓扑序不是唯一的，要保证不缺前置条件；拓扑要求是有向图且其中没有环；
7、Kruskal针对无向图；
8、窗口是想象出来的结构，左闭右开的结构[i ,  j)
9、暴力递归的可变参数都是简单数据类型；
遇到的问题：

是否解决：
建议：