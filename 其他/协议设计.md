## 协议设计的目标

![image-20250808225234706](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250808225234706.png)

## 从0设计协议

1. 客户端需要封装信息，服务端解析信息，还要判断消息的类型（单聊、群聊等）
2. 消息的边界问题，协议要能识别出边界，考虑如何切割。

### 案例1

![image-20250808230126412](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250808230126412.png)

![image-20250808232912265](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250808232912265.png)

![image-20250808235648490](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250808235648490.png)

### 案例2

![image-20250809000251651](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250809000251651.png)

![image-20250809001415395](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250809001415395.png)

### 案例3

![image-20250809001646467](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250809001646467.png)

### 案例4

![image-20250809014219814](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250809014219814.png)

![image-20250809014310879](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250809014310879.png)

## 发送方和接收方如何接收

![image-20250809014441950](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250809014441950.png)

### 序列化选型

3种方式

使用protobuf做序列化和反序列化，需要先定义proto结构体文件，生成pb.go文件。

### 协议代码设计--头部

![image-20250809024528034](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250809024528034.png)

### 序列化和反序列化具体操作

![image-20250809024912963](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250809024912963.png)

golang如何对结构体的单个字段做序列化和反序列化  

## 协议设计（2）

![image-20250809030140688](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250809030140688.png)

### 定义好消息协议结构体

消息头

![image-20250809175611811](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250809175611811.png)

整个消息

![image-20250809120832307](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250809120832307.png)

### 定义编解码器

这为了要让协议传递得更快



需要一个一个读取定义的协议体字段



测试用例：

![image-20250809162513020](C:\Users\Mr chen\AppData\Roaming\Typora\typora-user-images\image-20250809162513020.png)





Close()部分这里只是发了结束帧，并没有真正 `w.conn.Close()`，说明你的协议允许**连接复用**（多轮读写）。

`ReadFull` 会从 `r` 中读取字节，**直到把 `buf` 填满为止** 或遇到错误。它适合用来读取固定长度的字段（例如协议头、长度字段等）。

**返回值与常见错误情况：**

- 成功读取了 **完全填满** `buf`：返回 `n == len(buf)`，`err == nil`。
- 在读取**之前就遇到 EOF**（即还没读到任何字节就 EOF）：返回 `n == 0`，`err == io.EOF`。
- 在读取过程中遇到 EOF，已读到 **部分字节但不足 len(buf)**：返回已读的 `n`，且 `err == io.ErrUnexpectedEOF`。
- 在读取过程中遇到其他错误（非 EOF）：返回已读的 `n`（可能为 0 或正数），和该错误 `err`。