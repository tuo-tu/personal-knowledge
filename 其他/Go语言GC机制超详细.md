## GC简介

垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自**动的内存管理机制**，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。

简单地说，垃圾回收(GC)是在后台运行一个**守护线程**，它的作用是在监控各个对象的状态，**识别并且丢弃不再使用的对象**来释放和重用资源。Golang使用的垃圾回收机制是**三色标记法**。GC过程和其他用户goroutine可并发运行，但需要一定时间的**STW(stop the world)**，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，Golang进行了**多次的迭代优化**来解决这个问题。

## 标记-清除法

Go V1.3之前的标记-清除(mark and sweep)算法。这个算法主要有两个步骤：

- 标记(Mark phase)
- 清除(Sweep phase)

**第一步**，暂停程序业务逻辑，找出不可达的对象，然后做上标记。第二步，回收标记好的对象。

操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，**需要程序暂停**！即 STW(stop the world)。也就是说，这段时间程序会卡在哪儿。

> Stop-the-world意味着从应用中停下来并进入到GC执行过程中去。一旦Stop-the-world发生，除了GC所需的线程外，其他线程都将停止工作，中断了的线程直到GC任务结束才继续它们的任务。

<img src="https://pica.zhimg.com/v2-71e3455b8aa8cc7214d927baeb4ad66e_r.jpg" alt="img" style="zoom:50%;" />

**第二步**，开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：

<img src="https://picx.zhimg.com/v2-87f34550d1f340773c67af31456fb429_r.jpg" alt="img" style="zoom:50%;" />

> 其中这个箭头的指向代表一个对象引用了另外一个对象。比如对象1和对象2之间存在对象1到对象2的箭头，这就表示对象1引用了对象2。

**第三步**，标记完了之后，然后开始**清除未标记的对象**。结果如下：

<img src="https://picx.zhimg.com/v2-12295223c69ab1b8aefeb9176851544f_r.jpg" alt="img" style="zoom:50%;" />

**第四步**，停止暂停，让程序继续跑。然后**循环重复这个过程**，直到process程序生命周期结束。

## 标记-清除(mark and sweep)的缺点

- STW，stop the world；让程序暂停，程序出现卡顿 **(重要问题)**。
- 标记需要扫描整个heap（堆）
- 清除数据会产生heap碎片

所以Go V1.3版本之前就是以上来实施的，流程是：

![img](https://picx.zhimg.com/v2-3d9716d403143b3f8bae10c03d44745f_r.jpg)

Go V1.3 做了简单的优化，将STW提前，减少STW暂停的时间范围。如下所示：

![img](https://picx.zhimg.com/v2-c705928d8a6066b6ffcc4a1a5f7f0cbf_r.jpg)

这里面最重要的问题就是：**mark-and-sweep 算法会暂停整个程序。**

Go是如何面对并解决这个问题的呢？接下来G V1.5版本 就用**三色并发标记法**来优化这个问题。

## Go V1.5的三色并发标记法

三色标记法实际上就是通过**三个阶段的标记**来确定清楚的对象都有哪些。我们来看一下具体的过程。

> 三色标记法当中有三种颜色：
>
> - **白色：**对象未访问过；
> - **灰色：**对象已访问过，但是本对象引用到的其他对象尚未全部访问完。全部访问后，会转换为黑色；
> - **黑色：**对象已访问过，而且本对象引用到的其他对象也全部访问过了。

**第一步** , 就是只要是新创建的对象，默认的颜色都是标记为“白色”。并且会被放入白色集合当中，如下图所示：

<img src="https://i-blog.csdnimg.cn/blog_migrate/45fae57c4883448b0b930cb6c1c982c7.jpeg#pic_center" alt="img"  />

这个非常的简单，但是把所有的白色对象放入到白色集合这个过程是需要STW的也就是暂停程序。这里面需要注意的是，所谓“程序”，指的是一些对象的**根节点集合。**

![img](https://i-blog.csdnimg.cn/blog_migrate/c43034c224e2d1c91d7a0430af5a171f.jpeg#pic_center)

在这里解释一下什么叫做根节点集合：root区域主要是**程序运行到当前时刻的栈和全局数据区域**。这点需要搞明白。

**第二步：**每次GC的时候从**根节点集合开始遍历**可达节点，并把遍历到的白色对象从白色集合当中放入到灰色集合当中。

![img](https://i-blog.csdnimg.cn/blog_migrate/dd9c5830a322809907f3ea0854fd1eb7.png)

**第三步：**遍历灰色集合，将灰色集合当中的对象引用的白色对象放入到灰色集合当中。放入完毕之后将灰色对象放入到黑色集合当中。

![img](https://i-blog.csdnimg.cn/blog_migrate/66f973df03f596d20d51c272a0c63932.png)

**第四步：**也就是重复第三步**直到灰色集合当中无对象。**

![img](https://i-blog.csdnimg.cn/blog_migrate/9ee602872b6c7788448dd280be885671.png)

**第五步：**回收无用对象，也就是**剩下的白色对象。**

![img](https://i-blog.csdnimg.cn/blog_migrate/62f285b4c46ceeef226f7ad0fb5e2462.png)

以上就是三色遍历法的全部过程，有点类似宽度优先遍历（类似二叉树的层序遍历)。下面总结一下：

> 1. 初始时，所有对象都在【白色集合】中；（搜索白色集合需要STW）
> 2. 将GC Roots 直接引用到的对象 挪到 【灰色集合】中。
> 3. 从灰色集合中获取对象：
>    1. 将本对象 引用到的 其他对象 全部挪到 【灰色集合】中。
>    2. 将本对象 挪到 【黑色集合】里面。
> 4. 重复步骤3，**直至【灰色集合】为空时结束。**
> 5. 结束后，仍在【白色集合】的对象即为GC Roots 不可达，可以进行回收。

![img](https://i-blog.csdnimg.cn/blog_migrate/86790aec09209c540501a0d7d4c2426a.gif#pic_center)

下面我们已经明白了三次标记法的大致流程和思路，那么这样的三色标记法就可以不使用STW（暂停程序）了吗？

下面我们来看看这个问题。我们还是基于上述的三色并发标记法来说，他是一定要依赖STW的。因为如果不暂停程序，程序的逻辑改变会改变对象引用关系，这种动作如果在标记阶段做了修改，会影响标记结果的正确性。

我们举一个场景：如果三色标记法标记过程不使用STW将会发生什么事情？

<img src="https://i-blog.csdnimg.cn/blog_migrate/59efccfb99d3cda0ebd4e9d45f96cac3.png" alt="img"  />

已标记为灰色的对象2有指针指向对象3，或者我们说引用了对象3。**如果我们不再STW**，那么此时在这种情况下就可能出现问题了。此时在进行GC但是程序也是在运行的，此时若黑色对象4创建了一个指针指向了白色对象3，并且这个黑色对象2删除了和对象3的引用关系。

![img](https://i-blog.csdnimg.cn/blog_migrate/9f656ab56617cc0eeb67b5f3243d12a8.png)

![img](https://i-blog.csdnimg.cn/blog_migrate/d36e2b10344c2283533852406ea48750.png)

那么此时最后的结果就会变为如下情形。

> 因为对象4已经变成黑色了，而不管怎么样对象3还是白色，因此会被清除。

![img](https://i-blog.csdnimg.cn/blog_migrate/0a8daa8bd1a100fbf60d2c2e05df4698.png)

此时对象3被当成垃圾被回收了，这是我们不允许出现的。通过了上述流程的分析我们发现这种情况是三色标记法最不希望发生的：

- 一个**白色对象被黑色对象所引用。**

- 灰色对象和与它有可达关系的白色对象遭到破坏（灰色丢了该白色，或者理解为**灰色对象删除了和白色对象的引用关系**）。

如果这两种情况同时发生那么白色对象就可能会被当做垃圾被回收掉，那么这个问题该如何解决呢？最简单的办法就是STW暂停程序。但是STW又会影响这个程序的效率，**如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？**

为了解决这个问题，谷歌团体引入了**两个屏障机制**来解决这个问题。

通过上面的分析我们发现，如果上面这两种情况同时满足，就会导致白色对象被当做垃圾回收掉。如果我们**破坏掉一个条件**是不是就可以了。因此谷歌团队引入了**强弱三色不变式。**

- 首先我们来看看这个**强三色不变式：不允许黑色对象引用白色对象。**

<img src="https://i-blog.csdnimg.cn/blog_migrate/071d21279b8844a761af5ea258b5e221.png" alt="img" style="zoom:67%;" />

- 其次是这个**弱三次不变式：所有被黑色对象引用的白色对象都处于灰色保护状态。**

  假设允许第一个条件，只破坏第二个条件，即黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。这个就叫做**弱三色不变式。**

<img src="https://i-blog.csdnimg.cn/blog_migrate/28a7b666424c156f7e89785b83fbc81c.png" alt="img" style="zoom: 50%;" />

通过这两种方式，谷歌团队引入了这个**插入屏障和删除屏障。**

## 插入屏障（满足强三色不变式）

首先我们来看看这个具体的操作是如何做的： 

在A对象引用B对象的时候，B对象被标记为灰色（如果对象B是白色）。满足强三色不变式（不存在黑色对象引用白色对象的情况了， 因为**白色会强制变成灰色**）。

> 黑色对象的内存槽有两种位置：栈和堆。栈空间的特点是容量小，但是要求响应速度快。因为函数调用弹出频繁使用，所以“插入屏障”机制在**栈空间的对象操作中不使用**，而仅仅在堆空间对象的操作中使用。
>
> 但是如果栈不添加，当全部三色标记扫描之后，栈上有可能依然存在白色对象被黑色引用的情况，所以最后要**对栈重新进行三色标记扫描**，但这次为了对象不丢失，要对本次标记扫描**启动STW暂停**，直到栈空间的三色标记结束。

下面我们来举一个例子：

A之前没有引用任何对象，现在让其引用一个对象B，对象B会被置为灰色。还有一种情况就是A之前引用了对象C，现在A想引用B，不引用C了（即A将下游对象C更换为B），此时B也会被置为灰色。

> **A** 之前没有下游， 新添加一个下游对象**B**， **B**被标记为灰色。
>
> **A** 将下游对象C 更换为**B**，  **B**被标记为灰色。

下面我们通过几张图来看看这个这个过程的大致是个什么情况。

![img](https://i-blog.csdnimg.cn/blog_migrate/a51610654b9a3d034f3c9e01a05612f9.png)

上面的过程和三色标记法一样，一开始需要将白色对象放到白色集合当中。在这里需要注意的是在**这里的栈是不开启插入写屏障的，为了保证栈的效率。**

![img](https://i-blog.csdnimg.cn/blog_migrate/f32e1dbcaefb73d47cd843ed9032fd6f.png)

![img](https://i-blog.csdnimg.cn/blog_migrate/ad87b39a6f0914c3f0c3b64b49a2f69c.png)

- 由于堆没有使用STW暂停程序，因此黑色对象引用了这个白色对象8，那么此时开启这个插入屏障，白色对象8会被置为灰色。
- 由于栈不开启插入屏障，所以对象9并不会被标记为灰色。

![img](https://i-blog.csdnimg.cn/blog_migrate/265635750f98ad70e02cc6f495a49032.png)

然后继续三色标记法的流程，遍历完成后的样子大致是这样。

注意：此时栈还没有启动STW暂停（或者说还没有重新进行三色标记扫描），所以对象9是白色。

![img](https://i-blog.csdnimg.cn/blog_migrate/5f7d17d08e75d7cc37196d70f55be907.png)

但是可能就有老铁说了，此时对象9不会被当作是垃圾而被清除掉吗？此时在处理回收这个白色对象时，会开启STW。注意只是对栈开启STW，接着将栈里面的对象全部置为白色，重新进行上述三色标记扫描过程，这样就能保证这个对象9不会被误删。

![img](https://i-blog.csdnimg.cn/blog_migrate/c0ec0377e468254bb9fecf91767e0178.png)

最后，结果应该是这样的。

![img](https://i-blog.csdnimg.cn/blog_migrate/785714a11c3ea45594b3aa4ac443435a.png)

然后将白色对象清理完毕之后就可以暂停这个SWT了。但是这种方法还是需要暂停这个栈区，没有完全的摆脱SWT。后面总结时再详细说明。

## 删除屏障（满足弱三色不变式）

删除屏障是指：被删除引用关系的对象，如果自身为灰色或者白色，那么被标记为灰色。这一点其实就是为了满足弱三色不变式。满足弱三色不变式（保护灰色对象到白色对象的路径不会断）

下面我们举个例子来说明这种情况：

比如A此时引用了B对象，但是此时A要删除和对象B的引用关系，此时如果B对象是白色对象，那么B对象会被置为灰色。还有一种情况就是A对象之前引用了B对象，此时A更换引用关系，引用C，也就是A对象和B对象之间的引用关系被删除掉了，此时B对象会被置为灰色。

> **A**对象，删除**B**对象的引用。**B**被**A**删除，被标记为灰(如果**B**之前为白)
>
> **A**对象，更换下游**B**变成C。**B**被**A**删除，被标记为灰(如果**B**之前为白)

下面我们来通过几张图来看看这个删除屏障。

![img](https://i-blog.csdnimg.cn/blog_migrate/297f4c4c56b11d33aac4e6fa9506fc36.png)

首先第一步还是按照三色标记法的步骤来，将所有的**白色节点放入到栈中**，这一步和三色标记法是一样的。然后我们继续这个上述流程。

![img](https://i-blog.csdnimg.cn/blog_migrate/7178ae1043efe2da50cd91c280091502.png)

此时对象1想要删除和对象5之间的引用关系，此时就会**触发删除（写）屏障。**

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ca2022b1e7b3cc80d1bb5513995fff6e.png)

然后继续三色标记法的步骤也是一样的。

![img](https://i-blog.csdnimg.cn/blog_migrate/e6383fe112fcb7d0d7a5461955cd7d45.png)

最后的情况就是，对象6被删除了。

![img](https://i-blog.csdnimg.cn/blog_migrate/08b949bdc164952891c590e050074602.png)

可能有老铁要说了，对象5、对象2、对象3不是垃圾吗？不应该被回收吗。为什么保留下来了？是的在这一次GC过程当中他们确实是被保留下来了，但是**下一轮GC的时候就会被干掉了。**

总结：

1. 这种方式的**回收精度低**，一个对象即使被删除了最后一个指向它的指针，它也依旧可以活过这一轮，**在下一轮GC中被清理掉。**
2. **需要STW暂停这个栈**，包含栈再次GC，虽然栈里面的对象数量不是很多，但是仍然需要SWT。在一定程度上还是会影响效率。

## Go V1.8的混合写屏障

Go V1.8的混合写屏障(hybrid write barrier)机制。

> 混合写屏障规则
>
> 具体操作:
>
> 1. GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，
> 2. GC期间，任何在栈上创建的新对象，均为黑色。
> 3. 被删除的对象标记为灰色。
> 4. 被添加的对象标记为灰色。
>
> 满足: 变形的弱三色不变式

混合写屏障机制的引入主要是为了解决这个三色标记法当中需要给栈区使用SWT暂停。另外需要重复进行一次GC的缺点。下面我们在这里总结一下插入写屏障和删除写屏障的缺点，然后再来看看这个混合写屏障机制。

- 插入写屏障：结束时需要STW来重新**扫描栈**，标记栈上引用的白色对象的存活与否；

- 删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。

Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。下面我们一起来了解一下这个机制是怎么回事。

**混合写屏障：**

1. 一开始将栈上的可达对象全部标记为黑色；
2. 在GC期间，任何在**栈上**新创建的对象均为黑色；
3. 堆上被删除引用的对象均标记为灰色；
4. 堆上新添加引用的对象均标记为灰色。

> 伪代码：
>
> ```
> 添加下游对象(当前下游对象slot, 新下游对象ptr) {
>   	//1 
> 	标记灰色(当前下游对象slot)    // 只要当前下游对象被移走（删除），就标记灰色
>   	
>   	//2 
>   	标记灰色(新下游对象ptr)
>   		
>   	//3
>   	当前下游对象slot = 新下游对象ptr
> }
> ```

**栈不开启屏障机制，其主要为了满足（变形）弱三色不变式。**注意混合写屏障是GC的一种屏障机制，所以只是当程序**执行GC的时候**，才会触发这种机制。下面我们来分析这种方法的可行性。

![img](https://i-blog.csdnimg.cn/blog_migrate/48cef178c022bdd46198a6148c652ff4.png)

请注意GC刚开始所有对象都是白色的，然后第一步我们扫描**栈区**，将栈上的对象**全部标记为黑色。**

![img](https://i-blog.csdnimg.cn/blog_migrate/5c380958d944cd970135bc5d922c5d96.png)

下面我们看看以下四种常见情况，在混合写屏障的机制下

**情况一：**对象被一个**堆对象**删除引用，成为栈对象的下游。

![img](https://i-blog.csdnimg.cn/blog_migrate/51b497eb068f12be9580afc899085442.png)

对象1添加引用关系到对象7，此时因为栈是**不开启任何屏障机制**的，所以**直接添加**即可。此时对象4删除和对象7的引用关系。

![img](https://i-blog.csdnimg.cn/blog_migrate/5189764db3496570dc75dee510f25d39.png)

此时对象4删除了和对象7的引用关系，那么按照规则我们需要将对象7置为灰色。此时我们发现不会有任何错误。

**情况二：**对象被一个**栈对象**删除引用，成为另一个栈对象的下游。

![img](https://i-blog.csdnimg.cn/blog_migrate/1cac6a5abb075b49ff42a6d3c70830eb.png)

首先在栈上新建一个对象9，按照规则在栈上创建的对象均为黑色对象。

![img](https://i-blog.csdnimg.cn/blog_migrate/c5b2f8e95771e26d46bf038679518f2a.png)

添加对象9到对象3的引用关系，由于这个栈不启动任何屏障，直接添加即可。

![img](https://i-blog.csdnimg.cn/blog_migrate/a4d7f789097352c97be842713b903790.png)

接着对象2删除和对象3之间的引用关系，由于是在栈上，所以直接删除即可。此时也是没有任何问题，不存在误删的情况。

**情况三：**对象被一个**堆对象**删除引用，成为另一个堆对象的下游。

![img](https://i-blog.csdnimg.cn/blog_migrate/dba0d257d7cd43bd1018c517c41c527b.png)

对象10想要添加这个引用关系和对象7。

![img](https://i-blog.csdnimg.cn/blog_migrate/7742a462d2df9d3159903029f3dfe953.png)

由于是在**堆上**，所以会触发这个屏障机制，会将对象7变为灰色。对象7变为灰色之后，就不会被当中垃圾被回收了。

**情况四：**对象从一个栈对象删除引用，成为另一个堆对象的下游。

![img](https://i-blog.csdnimg.cn/blog_migrate/04dc3401d917000fb218066f21cc6aca.png)

对象1想要删除和对象2之间的引用关系，由于栈不开启这个屏障机制，所以直接删除即可。

![img](https://i-blog.csdnimg.cn/blog_migrate/9eb87843f1728a3a402820f04aeb49de.png)

对象4尝试引用对象2，**对象2本来就是黑色了，所以不用管。**

![img](https://i-blog.csdnimg.cn/blog_migrate/8a0209f3508d43f82cf6b3f7a3235337.png)

对象1删除和对象2之间的引用关系直接删了就可以，对象4删除和对象7之间的引用关系，此时由于是在堆上所以了触发了这个混合写屏障机制，将对象7置为灰色。

可能有老铁就要问了，对象7和对象6现在不是属于垃圾对象了吗？应该被回收。但是对象7是灰色，这会让对象7和对象6不被回收掉。是的，在这一轮GC的情况下确实不会被回收，但是下一轮GC就会将对象7和对象6回收掉。这一点设计者是考虑到了的。

总结：

> Golang中的混合写屏障满足`弱三色不变式`，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的**栈**，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。

